"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Accordion: () => Accordion,
  AccordionButton: () => AccordionButton,
  AccordionHeader: () => AccordionHeader,
  AccordionItem: () => AccordionItem,
  AccordionPanel: () => AccordionPanel,
  Alert: () => Alert,
  AlertDialog: () => AlertDialog,
  AlertDialogDescription: () => AlertDialogDescription,
  AlertDialogOverlay: () => AlertDialogOverlay,
  AlertDialogPanel: () => AlertDialogPanel,
  AlertDialogTitle: () => AlertDialogTitle,
  AutocompleteStateChild: () => AutocompleteStateChild,
  Button: () => Button,
  CheckStateChild: () => CheckStateChild,
  Checkbox: () => Checkbox,
  CheckboxDescription: () => CheckboxDescription,
  CheckboxIndicator: () => CheckboxIndicator,
  CheckboxLabel: () => CheckboxLabel,
  ColorSchemeProvider: () => ColorSchemeProvider,
  Combobox: () => Combobox,
  ComboboxInput: () => ComboboxInput,
  ComboboxLabel: () => ComboboxLabel,
  ComboboxOption: () => ComboboxOption,
  ComboboxOptions: () => ComboboxOptions,
  Command: () => Command,
  CommandBar: () => CommandBar,
  CommandBarDescription: () => CommandBarDescription,
  CommandBarOverlay: () => CommandBarOverlay,
  CommandBarPanel: () => CommandBarPanel,
  CommandBarTitle: () => CommandBarTitle,
  CommandInput: () => CommandInput,
  CommandLabel: () => CommandLabel,
  CommandOption: () => CommandOption,
  CommandOptions: () => CommandOptions,
  ContextMenu: () => ContextMenu,
  ContextMenuBoundary: () => ContextMenuBoundary,
  ContextMenuOverlay: () => ContextMenuOverlay,
  ContextMenuPanel: () => ContextMenuPanel,
  Dialog: () => Dialog,
  DialogDescription: () => DialogDescription,
  DialogOverlay: () => DialogOverlay,
  DialogPanel: () => DialogPanel,
  DialogTitle: () => DialogTitle,
  Disclosure: () => Disclosure,
  DisclosureButton: () => DisclosureButton,
  DisclosurePanel: () => DisclosurePanel,
  DisclosureStateChild: () => DisclosureStateChild,
  Feed: () => Feed,
  FeedArticle: () => FeedArticle,
  FeedArticleDescription: () => FeedArticleDescription,
  FeedArticleLabel: () => FeedArticleLabel,
  FeedContent: () => FeedContent,
  FeedLabel: () => FeedLabel,
  Fragment: () => Fragment,
  InputStateChild: () => InputStateChild,
  Listbox: () => Listbox,
  ListboxButton: () => ListboxButton,
  ListboxLabel: () => ListboxLabel,
  ListboxOption: () => ListboxOption,
  ListboxOptions: () => ListboxOptions,
  Menu: () => Menu,
  MenuChild: () => MenuChild,
  MenuItem: () => MenuItem,
  Popover: () => Popover,
  PopoverButton: () => PopoverButton,
  PopoverOverlay: () => PopoverOverlay,
  PopoverPanel: () => PopoverPanel,
  RadioGroup: () => RadioGroup,
  RadioGroupDescription: () => RadioGroupDescription,
  RadioGroupLabel: () => RadioGroupLabel,
  RadioGroupOption: () => RadioGroupOption,
  Select: () => Select,
  SelectOption: () => SelectOption,
  SelectOptionStateChild: () => SelectOptionStateChild,
  SelectStateChild: () => SelectStateChild,
  Tab: () => Tab,
  TabGroup: () => TabGroup,
  TabList: () => TabList,
  TabPanel: () => TabPanel,
  Toast: () => Toast,
  Toaster: () => Toaster,
  ToasterStore: () => ToasterStore,
  Toggle: () => Toggle,
  ToggleStateChild: () => ToggleStateChild,
  Toolbar: () => Toolbar,
  Transition: () => Transition,
  TransitionChild: () => TransitionChild,
  createCheckState: () => createCheckState,
  createDisclosureState: () => createDisclosureState,
  createInputState: () => createInputState,
  createMultipleAutocompleteState: () => createMultipleAutocompleteState,
  createMultipleSelectState: () => createMultipleSelectState,
  createSelectOptionState: () => createSelectOptionState,
  createSingleAutocompleteState: () => createSingleAutocompleteState,
  createSingleSelectState: () => createSingleSelectState,
  createToggleState: () => createToggleState,
  useAutocompleteState: () => useAutocompleteState,
  useCheckState: () => useCheckState,
  useColorScheme: () => useColorScheme,
  useDisclosureState: () => useDisclosureState,
  useInputState: () => useInputState,
  useNativeColorScheme: () => useNativeColorScheme,
  usePreferredColorScheme: () => usePreferredColorScheme,
  useSelectOptionState: () => useSelectOptionState,
  useSelectState: () => useSelectState,
  useToaster: () => useToaster,
  useToggleState: () => useToggleState
});
module.exports = __toCommonJS(src_exports);

// src/components/accordion/Accordion.ts
var import_solid_js7 = require("solid-js");
var import_props = require("solid-use/props");

// src/states/create-select-state.ts
var import_solid_js = require("solid-js");

// src/utils/assert.ts
function assert(cond, error) {
  if (!cond) {
    throw error;
  }
}

// src/utils/is-equal.ts
function isEqual(a, b) {
  return a === b || a !== a && b !== b;
}

// src/states/create-select-state.ts
function createSingleSelectState(options) {
  const [active, setActive] = (0, import_solid_js.createSignal)();
  let selectedValue;
  let setSelectedValue;
  const equals = options.by || isEqual;
  if ("defaultValue" in options) {
    const [selected, setSelected] = (0, import_solid_js.createSignal)(
      options.defaultValue
    );
    selectedValue = selected;
    setSelectedValue = (value) => {
      setSelected(() => value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    selectedValue = (0, import_solid_js.createMemo)(() => options.value);
    setSelectedValue = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = (0, import_solid_js.createMemo)(() => !!options.disabled);
  return {
    isSelected(value) {
      return isEqual(value, selectedValue());
    },
    select(value) {
      if (!(0, import_solid_js.untrack)(isDisabled)) {
        if (options.toggleable && equals((0, import_solid_js.untrack)(selectedValue), value)) {
          setSelectedValue(void 0);
        } else {
          setSelectedValue(value);
        }
      }
    },
    hasSelected() {
      return selectedValue() != null;
    },
    disabled: isDisabled,
    hasActive() {
      return !!active();
    },
    isActive(value) {
      const ref = active();
      return ref ? equals(value, ref.value) : false;
    },
    focus(value) {
      if (!(0, import_solid_js.untrack)(isDisabled)) {
        setActive({
          value
        });
      }
    },
    blur() {
      if (!(0, import_solid_js.untrack)(isDisabled)) {
        setActive(void 0);
      }
    }
  };
}
function createMultipleSelectState(options) {
  const [active, setActive] = (0, import_solid_js.createSignal)();
  let selectedValues;
  let setSelectedValues;
  const equals = options.by || isEqual;
  if ("defaultValue" in options) {
    const [selected, setSelected] = (0, import_solid_js.createSignal)(options.defaultValue);
    selectedValues = selected;
    setSelectedValues = (value) => {
      setSelected(() => value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    selectedValues = (0, import_solid_js.createMemo)(() => options.value);
    setSelectedValues = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = (0, import_solid_js.createMemo)(() => !!options.disabled);
  return {
    isSelected(value) {
      const values = selectedValues();
      for (let i = 0, len = values.length; i < len; i += 1) {
        if (equals(value, values[i])) {
          return true;
        }
      }
      return false;
    },
    select(value) {
      if (!(0, import_solid_js.untrack)(isDisabled)) {
        const newValues = [];
        const currentValues = (0, import_solid_js.untrack)(selectedValues);
        let hasValue = false;
        for (let i = 0, len = currentValues.length; i < len; i += 1) {
          const item = currentValues[i];
          const isSame = equals(item, value);
          if (isSame) {
            hasValue = true;
          }
          if (!(options.toggleable && isSame)) {
            newValues.push(item);
          }
        }
        if (!hasValue) {
          newValues.push(value);
        }
        setSelectedValues(newValues);
      }
    },
    hasSelected: (0, import_solid_js.createMemo)(() => selectedValues().length > 0),
    disabled: isDisabled,
    hasActive: (0, import_solid_js.createMemo)(() => !!active()),
    isActive(value) {
      const ref = active();
      if (ref) {
        return equals(value, ref.value);
      }
      return false;
    },
    focus(value) {
      if (!(0, import_solid_js.untrack)(isDisabled)) {
        setActive({
          value
        });
      }
    },
    blur() {
      if (!(0, import_solid_js.untrack)(isDisabled)) {
        setActive(void 0);
      }
    }
  };
}
var SelectStateContext = (0, import_solid_js.createContext)();
function SelectStateProvider(props) {
  return (0, import_solid_js.createComponent)(SelectStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useSelectState() {
  const ctx = (0, import_solid_js.useContext)(SelectStateContext);
  assert(ctx, new Error("Missing <SelectStateProvider>"));
  return ctx;
}
function SelectStateChild(props) {
  const state = useSelectState();
  return (0, import_solid_js.createMemo)(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return (0, import_solid_js.createMemo)(() => current(state));
    }
    return current;
  });
}

// src/utils/create-dynamic.ts
var import_solid_js2 = require("solid-js");
var import_web = require("solid-js/web");
function createDynamic(source, props) {
  return (0, import_solid_js2.createComponent)(
    import_web.Dynamic,
    (0, import_solid_js2.mergeProps)(
      {
        get component() {
          return source();
        }
      },
      props
    )
  );
}

// src/utils/dynamic-prop.ts
var import_solid_js3 = require("solid-js");
function isRefFunction(callback) {
  return typeof callback === "function";
}
function createForwardRef(props) {
  const [ref, setRef] = (0, import_solid_js3.createSignal)();
  (0, import_solid_js3.createEffect)(() => {
    const current = ref();
    if (current && "ref" in props && isRefFunction(props.ref)) {
      props.ref(current);
    }
  });
  return [ref, setRef];
}

// src/utils/state-props.ts
function toBooleanish(value) {
  return value ? "" : void 0;
}
function createARIADisabledState(disabled) {
  return {
    get disabled() {
      return disabled();
    },
    get "aria-disabled"() {
      return disabled();
    }
  };
}
function createARIAExpandedState(expanded) {
  return {
    get "aria-expanded"() {
      return expanded();
    }
  };
}
function createARIACheckedState(checked) {
  return {
    get "aria-checked"() {
      var _a;
      return (_a = checked()) != null ? _a : "mixed";
    }
  };
}
function createARIASelectedState(selected) {
  return {
    get "aria-selected"() {
      return selected();
    }
  };
}
function createARIAPressedState(pressed) {
  return {
    get "aria-pressed"() {
      return pressed();
    }
  };
}
function createDisabledState(disabled) {
  return {
    get "tc-disabled"() {
      return toBooleanish(disabled());
    }
  };
}
function createExpandedState(expanded) {
  return {
    get "tc-expanded"() {
      return toBooleanish(expanded());
    }
  };
}
function createCheckedState(isChecked) {
  return {
    get "tc-checked"() {
      const result = isChecked();
      return result == null ? "mixed" : toBooleanish(result);
    }
  };
}
function createSelectedState(isSelected) {
  return {
    get "tc-selected"() {
      return toBooleanish(isSelected());
    }
  };
}
function createActiveState(isActive) {
  return {
    get "tc-active"() {
      return toBooleanish(isActive());
    }
  };
}
function createMatchesState(matches) {
  return {
    get "tc-matches"() {
      return toBooleanish(matches());
    }
  };
}
function createHasSelectedState(hasSelected) {
  return {
    get "tc-has-selected"() {
      return toBooleanish(hasSelected());
    }
  };
}
function createHasActiveState(hasActive) {
  return {
    get "tc-has-active"() {
      return toBooleanish(hasActive());
    }
  };
}
function createHasQueryState(hasQuery) {
  return {
    get "tc-has-query"() {
      return toBooleanish(hasQuery());
    }
  };
}
function createPressedState(pressed) {
  return {
    get "tc-pressed"() {
      return toBooleanish(pressed());
    }
  };
}

// src/utils/use-event-listener.ts
var import_solid_js4 = require("solid-js");
function useEventListener(node, type, listener, options) {
  node.addEventListener(type, listener, options);
  (0, import_solid_js4.onCleanup)(() => {
    node.removeEventListener(type, listener, options);
  });
}
var use_event_listener_default = useEventListener;

// src/components/accordion/AccordionContext.ts
var import_solid_js6 = require("solid-js");

// src/utils/focus-query.ts
var QUERY = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex]:not([tabindex="-1"]), [contenteditable]';
function getFocusableElements(node, filter) {
  const nodes = node.querySelectorAll(QUERY);
  const replicated = [];
  for (let i = 0, len = nodes.length; i < len; i += 1) {
    if (!(filter && filter.contains(nodes[i]))) {
      replicated.push(nodes[i]);
    }
  }
  return replicated;
}

// src/utils/namespace.ts
var DATA_SET_NAMESPACE = "tc";
var TYPE_ATTRIBUTE = `${DATA_SET_NAMESPACE}-type`;
var DISABLED_NODE = `[${DATA_SET_NAMESPACE}-disabled]`;
var SELECTED_NODE = `[${DATA_SET_NAMESPACE}-selected]`;
var CHECKED_NODE = `[${DATA_SET_NAMESPACE}-checked]`;
var MATCHES_NODE = `[${DATA_SET_NAMESPACE}-matches]`;
function createTag(tag) {
  return {
    [TYPE_ATTRIBUTE]: tag
  };
}

// src/utils/virtual-focus.ts
var import_solid_js5 = require("solid-js");
var LISTENERS = /* @__PURE__ */ new Set();
function useVirtualFocus(listener) {
  LISTENERS.add(listener);
  (0, import_solid_js5.onCleanup)(() => {
    LISTENERS.delete(listener);
  });
}
function focusVirtually(el) {
  for (const listener of LISTENERS.keys()) {
    listener(el);
  }
}

// src/utils/focus-navigation.ts
function isFocusable(el) {
  return !el.matches(DISABLED_NODE);
}
function getNextFocusable(nodes, anchor, direction, loop) {
  let current = anchor + direction;
  if (loop) {
    if (direction === 1 /* Next */ && current === nodes.length) {
      current = 0;
    }
    if (direction === -1 /* Prev */ && current === -1) {
      current = nodes.length - 1;
    }
    while (anchor !== current) {
      if (isFocusable(nodes[current])) {
        return nodes[current];
      }
      current += direction;
      if (direction === 1 /* Next */ && current >= nodes.length) {
        current = 0;
      }
      if (direction === -1 /* Prev */ && current < 0) {
        current = nodes.length - 1;
      }
    }
    return void 0;
  }
  while (current >= 0 && current < nodes.length) {
    if (isFocusable(nodes[current])) {
      return nodes[current];
    }
    current += direction;
  }
  return void 0;
}
function focusNode(node, virtual) {
  if (node) {
    if (virtual) {
      focusVirtually(node);
    } else {
      node.focus();
    }
  }
  return node;
}
function focusNext(nodes, targetNode, loop, virtual) {
  for (let i = 0, len = nodes.length; i < len; i += 1) {
    if (targetNode === nodes[i] || nodes[i].contains(targetNode)) {
      return focusNode(
        getNextFocusable(nodes, i, 1 /* Next */, loop),
        virtual
      );
    }
  }
  return void 0;
}
function focusPrev(nodes, targetNode, loop, virtual) {
  for (let i = 0, len = nodes.length; i < len; i += 1) {
    if (nodes[i].contains(targetNode)) {
      return focusNode(
        getNextFocusable(nodes, i, -1 /* Prev */, loop),
        virtual
      );
    }
  }
  return void 0;
}
function focusFirst(nodes, virtual) {
  if (nodes.length) {
    return focusNode(
      getNextFocusable(nodes, -1, 1 /* Next */, false),
      virtual
    );
  }
  return void 0;
}
function focusLast(nodes, virtual) {
  if (nodes.length) {
    return focusNode(
      getNextFocusable(nodes, nodes.length, -1 /* Prev */, false),
      virtual
    );
  }
  return void 0;
}
function focusMatch(nodes, character, virtual) {
  const lower = character.toLowerCase();
  for (let i = 0, l = nodes.length; i < l; i += 1) {
    const content = nodes[i].textContent;
    if (content != null && content.toLowerCase().startsWith(lower)) {
      return focusNode(nodes[i], virtual);
    }
  }
  return void 0;
}
function lockFocus(ref, reverse, virtual) {
  const nodes = getFocusableElements(ref);
  if (reverse) {
    if (!(document.activeElement && ref.contains(document.activeElement))) {
      return focusLast(nodes, virtual);
    }
    return focusPrev(
      nodes,
      document.activeElement,
      true,
      virtual
    );
  }
  if (!(document.activeElement && ref.contains(document.activeElement))) {
    return focusFirst(nodes, virtual);
  }
  return focusNext(nodes, document.activeElement, true, virtual);
}

// src/utils/focus-navigator.ts
var OWNER = `${DATA_SET_NAMESPACE}-owner`;
function queryNodes(el, ownerID, condition = "") {
  const query = `[${OWNER}="${ownerID}"]:not(${DISABLED_NODE})${condition}`;
  const nodes = el.querySelectorAll(query);
  return nodes;
}
function createOwnerAttribute(ownerID) {
  return {
    [OWNER]: ownerID
  };
}
var FocusNavigator = class {
  constructor(ownerID, options = {}) {
    var _a, _b;
    this.ownerID = ownerID;
    this.options = {
      virtual: (_a = options.virtual) != null ? _a : false,
      base: (_b = options.base) != null ? _b : ""
    };
  }
  setRef(ref) {
    this.internalRef = ref;
  }
  clearRef() {
    this.internalRef = void 0;
  }
  query(ref, condition = "") {
    return queryNodes(ref, this.ownerID, `${this.options.base}${condition}`);
  }
  setCurrent(node) {
    this.current = node;
  }
  setChecked(node) {
    this.current = focusNode(node, this.options.virtual);
  }
  setNextChecked(loop) {
    if (this.internalRef instanceof HTMLElement) {
      assert(this.current, new Error("missing current ref"));
      const current = focusNext(
        this.query(this.internalRef),
        this.current,
        loop,
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  setPrevChecked(loop) {
    if (this.internalRef instanceof HTMLElement) {
      assert(this.current, new Error("missing current ref"));
      const current = focusPrev(
        this.query(this.internalRef),
        this.current,
        loop,
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  setFirstChecked(condition = "") {
    if (this.internalRef instanceof HTMLElement) {
      const current = focusFirst(
        this.query(this.internalRef, condition),
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  setLastChecked(condition = "") {
    if (this.internalRef instanceof HTMLElement) {
      const current = focusLast(
        this.query(this.internalRef, condition),
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  setFirstMatch(character) {
    if (this.internalRef instanceof HTMLElement) {
      const current = focusMatch(
        this.query(this.internalRef),
        character,
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  getId() {
    return this.ownerID;
  }
};

// src/components/accordion/AccordionContext.ts
var AccordionContext = (0, import_solid_js6.createContext)();
function useAccordionContext(componentName) {
  const context = (0, import_solid_js6.useContext)(AccordionContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Accordion>`)
  );
  return context;
}
function createAccordionFocusNavigator() {
  return new FocusNavigator((0, import_solid_js6.createUniqueId)());
}

// src/components/accordion/tags.ts
var ACCORDION_TAG = createTag("accordion");
var ACCORDION_BUTTON_TAG = createTag("accordion-button");
var ACCORDION_HEADER_TAG = createTag("accordion-header");
var ACCORDION_ITEM_TAG = createTag("accordion-item");
var ACCORDION_PANEL_TAG = createTag("accordion-panel");

// src/components/accordion/Accordion.ts
function isAccordionUncontrolled(props) {
  return "defaultValue" in props;
}
function isAccordionMultiple(props) {
  return !!props.multiple;
}
function Accordion(props) {
  return (0, import_solid_js7.createMemo)(() => {
    const state = isAccordionMultiple(props) ? createMultipleSelectState(props) : createSingleSelectState(props);
    const controller = createAccordionFocusNavigator();
    const [ref, setRef] = createForwardRef(props);
    (0, import_solid_js7.createEffect)(() => {
      const current = ref();
      if (current instanceof HTMLElement) {
        controller.setRef(current);
        (0, import_solid_js7.onCleanup)(() => {
          controller.clearRef();
        });
        use_event_listener_default(current, "keydown", (e) => {
          if (!state.disabled()) {
            switch (e.key) {
              case "ArrowUp": {
                e.preventDefault();
                controller.setPrevChecked(true);
                break;
              }
              case "ArrowDown": {
                e.preventDefault();
                controller.setNextChecked(true);
                break;
              }
              case "Home": {
                e.preventDefault();
                controller.setFirstChecked();
                break;
              }
              case "End": {
                e.preventDefault();
                controller.setLastChecked();
                break;
              }
              default:
                break;
            }
          }
        });
        use_event_listener_default(current, "focusin", (e) => {
          if (e.target && e.target !== current) {
            controller.setCurrent(e.target);
          }
        });
      }
    });
    return (0, import_solid_js7.createComponent)(AccordionContext.Provider, {
      value: controller,
      get children() {
        return createDynamic(
          () => props.as || "div",
          (0, import_solid_js7.mergeProps)(
            isAccordionUncontrolled(props) ? (0, import_props.omitProps)(props, [
              "as",
              "by",
              "children",
              "defaultValue",
              "disabled",
              "multiple",
              "onChange",
              "ref",
              "toggleable"
            ]) : (0, import_props.omitProps)(props, [
              "as",
              "by",
              "children",
              "value",
              "disabled",
              "multiple",
              "onChange",
              "ref",
              "toggleable"
            ]),
            ACCORDION_TAG,
            {
              ref: setRef,
              id: controller.getId()
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createHasSelectedState(() => state.hasSelected()),
            createHasActiveState(() => state.hasActive()),
            {
              get children() {
                return (0, import_solid_js7.createComponent)(SelectStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    });
  });
}

// src/components/accordion/AccordionButton.ts
var import_solid_js11 = require("solid-js");
var import_props3 = require("solid-use/props");

// src/states/create-select-option-state.ts
var import_solid_js8 = require("solid-js");
function createSelectOptionState(options) {
  const state = useSelectState();
  const isDisabled = (0, import_solid_js8.createMemo)(() => options.disabled || state.disabled());
  return {
    isSelected: (0, import_solid_js8.createMemo)(() => state.isSelected(options.value)),
    isActive: (0, import_solid_js8.createMemo)(() => state.isActive(options.value)),
    select() {
      if (!(0, import_solid_js8.untrack)(isDisabled)) {
        state.select(options.value);
      }
    },
    focus() {
      if (!(0, import_solid_js8.untrack)(isDisabled)) {
        state.focus(options.value);
      }
    },
    blur() {
      if (!(0, import_solid_js8.untrack)(isDisabled) && this.isActive()) {
        state.blur();
      }
    },
    disabled: isDisabled
  };
}
var SelectOptionStateContext = (0, import_solid_js8.createContext)();
function SelectOptionStateProvider(props) {
  return (0, import_solid_js8.createComponent)(SelectOptionStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useSelectOptionState() {
  const ctx = (0, import_solid_js8.useContext)(SelectOptionStateContext);
  assert(ctx, new Error("Missing <SelectOptionStateProvider>"));
  return ctx;
}
function SelectOptionStateChild(props) {
  const state = useSelectOptionState();
  return (0, import_solid_js8.createMemo)(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return (0, import_solid_js8.createMemo)(() => current(state));
    }
    return current;
  });
}

// src/components/button/index.ts
var import_solid_js9 = require("solid-js");
var import_props2 = require("solid-use/props");
var BUTTON_TAG = createTag("button");
function Button(props) {
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js9.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      if (current.tagName !== "BUTTON") {
        use_event_listener_default(current, "keydown", (e) => {
          switch (e.key) {
            case "Enter":
            case " ": {
              current.click();
              break;
            }
          }
        });
      }
    }
  });
  return createDynamic(
    () => props.as || "button",
    (0, import_solid_js9.mergeProps)(
      {
        get tabindex() {
          return props.disabled ? -1 : 0;
        },
        role: "button"
      },
      createDisabledState(() => props.disabled),
      createARIADisabledState(() => props.disabled),
      (0, import_props2.omitProps)(props, ["as", "ref"]),
      BUTTON_TAG,
      {
        ref: setInternalRef
      }
    )
  );
}

// src/components/accordion/AccordionItemContext.ts
var import_solid_js10 = require("solid-js");
var AccordionItemContext = (0, import_solid_js10.createContext)();
function useAccordionItemContext(componentName) {
  const context = (0, import_solid_js10.useContext)(AccordionItemContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <AccordionItem>`)
  );
  return context;
}

// src/components/accordion/AccordionButton.ts
function AccordionButton(props) {
  const rootContext = useAccordionContext("AccordionButton");
  const itemContext = useAccordionItemContext("AccordionButton");
  const state = useSelectOptionState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => state.disabled() || props.disabled;
  (0, import_solid_js11.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          state.select();
        }
      });
      use_event_listener_default(current, "focus", () => {
        if (!isDisabled()) {
          state.focus();
        }
      });
      use_event_listener_default(current, "blur", () => {
        if (!isDisabled()) {
          state.blur();
        }
      });
    }
  });
  return (0, import_solid_js11.createComponent)(
    Button,
    (0, import_solid_js11.mergeProps)(
      (0, import_props3.omitProps)(props, ["children", "ref", "disabled"]),
      ACCORDION_BUTTON_TAG,
      {
        id: itemContext.buttonID,
        ref: setInternalRef,
        get "aria-controls"() {
          return state.isSelected() && itemContext.panelID;
        }
      },
      createOwnerAttribute(rootContext.getId()),
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createSelectedState(() => state.isSelected()),
      createExpandedState(() => state.isSelected()),
      createARIAExpandedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      {
        get children() {
          return (0, import_solid_js11.createComponent)(SelectOptionStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/accordion/AccordionHeader.ts
var import_solid_js12 = require("solid-js");
var import_props4 = require("solid-use/props");
function AccordionHeader(props) {
  useAccordionItemContext("AccordionHeader");
  const state = useSelectOptionState();
  return createDynamic(
    () => props.as || "h3",
    (0, import_solid_js12.mergeProps)(
      (0, import_props4.omitProps)(props, ["as", "children"]),
      ACCORDION_HEADER_TAG,
      createDisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createExpandedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      {
        get children() {
          return (0, import_solid_js12.createComponent)(SelectOptionStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/accordion/AccordionItem.ts
var import_solid_js13 = require("solid-js");
var import_props5 = require("solid-use/props");
function AccordionItem(props) {
  useAccordionContext("AccordionItem");
  const buttonID = (0, import_solid_js13.createUniqueId)();
  const panelID = (0, import_solid_js13.createUniqueId)();
  const state = createSelectOptionState(props);
  return (0, import_solid_js13.createComponent)(AccordionItemContext.Provider, {
    value: { buttonID, panelID },
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js13.mergeProps)(
          (0, import_props5.omitProps)(props, ["as", "children", "value", "disabled"]),
          ACCORDION_ITEM_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createSelectedState(() => state.isSelected()),
          createExpandedState(() => state.isSelected()),
          createActiveState(() => state.isActive()),
          {
            get children() {
              return (0, import_solid_js13.createComponent)(SelectOptionStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/accordion/AccordionPanel.ts
var import_solid_js15 = require("solid-js");
var import_props6 = require("solid-use/props");

// src/utils/create-unmountable.ts
var import_solid_js14 = require("solid-js");
function createUnmountable(props, shouldMount, render) {
  const mode = (0, import_solid_js14.createMemo)(() => props.unmount == null ? true : props.unmount);
  return (0, import_solid_js14.createMemo)(() => {
    const currentMode = mode();
    if (currentMode === "offscreen") {
      const condition = (0, import_solid_js14.createMemo)(() => shouldMount());
      const current = (0, import_solid_js14.children)(() => render());
      return (0, import_solid_js14.createMemo)(() => condition() && current);
    }
    if (currentMode) {
      const condition = (0, import_solid_js14.createMemo)(() => shouldMount());
      return (0, import_solid_js14.createMemo)(() => condition() && render);
    }
    return render;
  });
}

// src/components/accordion/AccordionPanel.ts
function AccordionPanel(props) {
  const context = useAccordionItemContext("AccordionPanel");
  const state = useSelectOptionState();
  return createUnmountable(
    props,
    () => state.isSelected(),
    () => createDynamic(
      () => props.as || "div",
      (0, import_solid_js15.mergeProps)(
        (0, import_props6.omitProps)(props, ["as", "children", "unmount"]),
        ACCORDION_PANEL_TAG,
        {
          id: context.panelID,
          "aria-labelledby": context.buttonID
        },
        createDisabledState(() => state.disabled()),
        createSelectedState(() => state.isSelected()),
        createExpandedState(() => state.isSelected()),
        createActiveState(() => state.isActive()),
        {
          get children() {
            return (0, import_solid_js15.createComponent)(SelectOptionStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        }
      )
    )
  );
}

// src/components/alert/index.ts
var import_solid_js16 = require("solid-js");
var import_props7 = require("solid-use/props");
var ALERT_TAG = createTag("alert");
function Alert(props) {
  const alertID = (0, import_solid_js16.createUniqueId)();
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js16.mergeProps)(
      {
        id: alertID
      },
      (0, import_props7.omitProps)(props, ["as"]),
      ALERT_TAG,
      {
        role: "alert"
      }
    )
  );
}

// src/components/alert-dialog/AlertDialog.ts
var import_solid_js20 = require("solid-js");
var import_props8 = require("solid-use/props");

// src/states/create-disclosure-state.ts
var import_solid_js17 = require("solid-js");
function createDisclosureState(options) {
  let signal;
  let setSignal;
  if ("defaultOpen" in options) {
    const [isOpen, setIsOpen] = (0, import_solid_js17.createSignal)(options.defaultOpen);
    signal = isOpen;
    setSignal = (value) => {
      setIsOpen(value);
      if (value && options.onOpen) {
        options.onOpen();
      }
      if (options.onChange) {
        options.onChange(value);
      }
      if (!value && options.onClose) {
        options.onClose();
      }
    };
  } else {
    signal = (0, import_solid_js17.createMemo)(() => options.isOpen);
    setSignal = (value) => {
      if (value && options.onOpen) {
        options.onOpen();
      }
      if (options.onChange) {
        options.onChange(value);
      }
      if (!value && options.onClose) {
        options.onClose();
      }
    };
  }
  const isDisabled = (0, import_solid_js17.createMemo)(() => !!options.disabled);
  return {
    isOpen() {
      return signal();
    },
    setState(value) {
      if (!(0, import_solid_js17.untrack)(isDisabled)) {
        setSignal(value);
      }
    },
    disabled: isDisabled,
    open() {
      if (!(0, import_solid_js17.untrack)(isDisabled)) {
        setSignal(true);
      }
    },
    close() {
      if (!(0, import_solid_js17.untrack)(isDisabled)) {
        setSignal(false);
      }
    },
    toggle() {
      if (!(0, import_solid_js17.untrack)(isDisabled)) {
        setSignal(!(0, import_solid_js17.untrack)(signal));
      }
    }
  };
}
var DisclosureStateContext = (0, import_solid_js17.createContext)();
function DisclosureStateProvider(props) {
  return (0, import_solid_js17.createComponent)(DisclosureStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useDisclosureState() {
  const ctx = (0, import_solid_js17.useContext)(DisclosureStateContext);
  assert(ctx, new Error("Missing <DisclosureStateProvider>"));
  return ctx;
}
function DisclosureStateChild(props) {
  const state = useDisclosureState();
  return (0, import_solid_js17.createMemo)(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return (0, import_solid_js17.createMemo)(() => current(state));
    }
    return current;
  });
}

// src/utils/use-focus-start-point.ts
var import_solid_js18 = require("solid-js");
var import_web2 = require("solid-js/web");

// src/utils/focus-start-point.ts
function getFocusStartPoint() {
  const selection = window.getSelection();
  if (selection) {
    const node = selection.focusNode;
    if (node) {
      return node.parentElement;
    }
  }
  return void 0;
}
function setFocusStartPoint(element) {
  if (element) {
    const tabindex = element.getAttribute("tabindex");
    element.setAttribute("tabindex", "-1");
    element.focus();
    element.blur();
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  }
}

// src/utils/use-focus-start-point.ts
var FocusStartPoint = class {
  constructor() {
    if (!import_web2.isServer) {
      this.returnElement = document.activeElement;
      this.fsp = getFocusStartPoint();
      (0, import_solid_js18.onCleanup)(() => {
        this.load();
      });
    }
  }
  load() {
    if (this.returnElement instanceof HTMLElement) {
      this.returnElement.focus();
    } else {
      setFocusStartPoint(this.fsp);
    }
  }
  save() {
    this.returnElement = document.activeElement;
    this.fsp = getFocusStartPoint();
  }
};
function useFocusStartPoint() {
  return new FocusStartPoint();
}

// src/components/alert-dialog/AlertDialogContext.ts
var import_solid_js19 = require("solid-js");
var AlertDialogContext = (0, import_solid_js19.createContext)();
function useAlertDialogContext(componentName) {
  const context = (0, import_solid_js19.useContext)(AlertDialogContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <AlertDialog>`)
  );
  return context;
}

// src/components/alert-dialog/tags.ts
var ALERT_DIALOG_TAG = createTag("alert-dialog");
var ALERT_DIALOG_DESCRIPTION_TAG = createTag(
  "alert-dialog-description"
);
var ALERT_DIALOG_OVERLAY_TAG = createTag("alert-dialog-overlay");
var ALERT_DIALOG_PANEL_TAG = createTag("alert-dialog-panel");
var ALERT_DIALOG_TITLE_TAG = createTag("alert-dialog-title");

// src/components/alert-dialog/AlertDialog.ts
function isAlertDialogUncontrolled(props) {
  return "defaultOpen" in props;
}
function AlertDialog(props) {
  const ownerID = (0, import_solid_js20.createUniqueId)();
  const panelID = (0, import_solid_js20.createUniqueId)();
  const titleID = (0, import_solid_js20.createUniqueId)();
  const descriptionID = (0, import_solid_js20.createUniqueId)();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  (0, import_solid_js20.createEffect)(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  return (0, import_solid_js20.createComponent)(AlertDialogContext.Provider, {
    value: {
      ownerID,
      panelID,
      titleID,
      descriptionID
    },
    get children() {
      return createUnmountable(
        props,
        () => state.isOpen(),
        () => createDynamic(
          () => props.as || "div",
          (0, import_solid_js20.mergeProps)(
            isAlertDialogUncontrolled(props) ? (0, import_props8.omitProps)(props, [
              "as",
              "children",
              "defaultOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]) : (0, import_props8.omitProps)(props, [
              "as",
              "children",
              "isOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]),
            ALERT_DIALOG_TAG,
            {
              id: ownerID,
              role: "alertdialog",
              "aria-modal": true,
              "aria-labelledby": titleID,
              "aria-describedby": descriptionID,
              get children() {
                return (0, import_solid_js20.createComponent)(DisclosureStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createExpandedState(() => state.isOpen())
          )
        )
      );
    }
  });
}

// src/components/alert-dialog/AlertDialogDescription.ts
var import_solid_js21 = require("solid-js");
var import_props9 = require("solid-use/props");
function AlertDialogDescription(props) {
  const context = useAlertDialogContext("AlertDialogDescription");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "p",
    (0, import_solid_js21.mergeProps)(
      (0, import_props9.omitProps)(props, ["as", "children"]),
      ALERT_DIALOG_DESCRIPTION_TAG,
      {
        id: context.descriptionID,
        get children() {
          return (0, import_solid_js21.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/alert-dialog/AlertDialogOverlay.ts
var import_solid_js22 = require("solid-js");
var import_props10 = require("solid-use/props");
function AlertDialogOverlay(props) {
  useAlertDialogContext("AlertDialogOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js22.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js22.mergeProps)(
      (0, import_props10.omitProps)(props, ["as", "children", "ref"]),
      ALERT_DIALOG_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return (0, import_solid_js22.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/alert-dialog/AlertDialogPanel.ts
var import_solid_js23 = require("solid-js");
var import_props11 = require("solid-use/props");
function AlertDialogPanel(props) {
  const context = useAlertDialogContext("AlertDialogPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js23.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      if (state.isOpen()) {
        focusFirst(getFocusableElements(current), false);
        use_event_listener_default(current, "keydown", (e) => {
          if (!props.disabled) {
            switch (e.key) {
              case "Tab": {
                e.preventDefault();
                lockFocus(current, e.shiftKey, false);
                break;
              }
              case "Escape": {
                state.close();
                break;
              }
              default:
                break;
            }
          }
        });
      }
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js23.mergeProps)(
      (0, import_props11.omitProps)(props, ["as", "children", "ref"]),
      ALERT_DIALOG_PANEL_TAG,
      {
        id: context.panelID,
        ref: setInternalRef,
        get children() {
          return (0, import_solid_js23.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/alert-dialog/AlertDialogTitle.ts
var import_solid_js24 = require("solid-js");
var import_props12 = require("solid-use/props");
function AlertDialogTitle(props) {
  const context = useAlertDialogContext("AlertDialogTitle");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "h2",
    (0, import_solid_js24.mergeProps)(
      (0, import_props12.omitProps)(props, ["as", "children"]),
      ALERT_DIALOG_TITLE_TAG,
      {
        id: context.titleID,
        get children() {
          return (0, import_solid_js24.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/checkbox/Checkbox.ts
var import_solid_js27 = require("solid-js");
var import_props13 = require("solid-use/props");

// src/states/create-check-state.ts
var import_solid_js25 = require("solid-js");
function createCheckState(options) {
  let signal;
  let setSignal;
  if ("defaultChecked" in options) {
    const [isOpen, setIsOpen] = (0, import_solid_js25.createSignal)(
      options.defaultChecked
    );
    signal = isOpen;
    setSignal = (value) => {
      setIsOpen(value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    signal = (0, import_solid_js25.createMemo)(() => options.checked);
    setSignal = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = (0, import_solid_js25.createMemo)(() => !!options.disabled);
  return {
    checked() {
      return signal();
    },
    setState(value) {
      if (!(0, import_solid_js25.untrack)(isDisabled)) {
        setSignal(value);
      }
    },
    disabled: isDisabled,
    check() {
      if (!(0, import_solid_js25.untrack)(isDisabled)) {
        setSignal(true);
      }
    },
    uncheck() {
      if (!(0, import_solid_js25.untrack)(isDisabled)) {
        setSignal(false);
      }
    },
    reset() {
      if (!(0, import_solid_js25.untrack)(isDisabled)) {
        setSignal(void 0);
      }
    },
    toggle() {
      if (!(0, import_solid_js25.untrack)(isDisabled)) {
        setSignal(!(0, import_solid_js25.untrack)(signal));
      }
    }
  };
}
var CheckStateContext = (0, import_solid_js25.createContext)();
function CheckStateProvider(props) {
  return (0, import_solid_js25.createComponent)(CheckStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useCheckState() {
  const ctx = (0, import_solid_js25.useContext)(CheckStateContext);
  assert(ctx, new Error("Missing <CheckStateProvider>"));
  return ctx;
}
function CheckStateChild(props) {
  const state = useCheckState();
  return (0, import_solid_js25.createMemo)(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return (0, import_solid_js25.createMemo)(() => current(state));
    }
    return current;
  });
}

// src/components/checkbox/CheckboxContext.ts
var import_solid_js26 = require("solid-js");
var CheckboxContext = (0, import_solid_js26.createContext)();
function useCheckboxContext(componentName) {
  const context = (0, import_solid_js26.useContext)(CheckboxContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Checkbox>`)
  );
  return context;
}

// src/components/checkbox/tags.ts
var CHECKBOX_TAG = createTag("checkbox");
var CHECKBOX_DESCRIPTION = createTag("checkbox-description");
var CHECKBOX_INDICATOR = createTag("checkbox-indicator");
var CHECKBOX_LABEL = createTag("checkbox-label");

// src/components/checkbox/Checkbox.ts
function isCheckboxUncontrolled(props) {
  return "defaultChecked" in props;
}
function Checkbox(props) {
  const ownerID = (0, import_solid_js27.createUniqueId)();
  const labelID = (0, import_solid_js27.createUniqueId)();
  const indicatorID = (0, import_solid_js27.createUniqueId)();
  const descriptionID = (0, import_solid_js27.createUniqueId)();
  const state = createCheckState(props);
  return (0, import_solid_js27.createComponent)(CheckboxContext.Provider, {
    value: {
      ownerID,
      labelID,
      indicatorID,
      descriptionID
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js27.mergeProps)(
          isCheckboxUncontrolled(props) ? (0, import_props13.omitProps)(props, [
            "as",
            "children",
            "defaultChecked",
            "disabled",
            "onChange"
          ]) : (0, import_props13.omitProps)(props, [
            "as",
            "children",
            "checked",
            "disabled",
            "onChange"
          ]),
          CHECKBOX_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createCheckedState(() => state.checked()),
          {
            get children() {
              return (0, import_solid_js27.createComponent)(CheckStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/checkbox/CheckboxDescription.ts
var import_solid_js28 = require("solid-js");
var import_props14 = require("solid-use/props");
function CheckboxDescription(props) {
  const context = useCheckboxContext("CheckboxDescription");
  const state = useCheckState();
  return createDynamic(
    () => props.as || "p",
    (0, import_solid_js28.mergeProps)(
      (0, import_props14.omitProps)(props, ["as", "children"]),
      CHECKBOX_DESCRIPTION,
      {
        id: context.descriptionID,
        get children() {
          return (0, import_solid_js28.createComponent)(CheckStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createCheckedState(() => state.checked())
    )
  );
}

// src/components/checkbox/CheckboxIndicator.ts
var import_solid_js29 = require("solid-js");
var import_props15 = require("solid-use/props");
function CheckboxIndicator(props) {
  const context = useCheckboxContext("CheckboxIndicator");
  const state = useCheckState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js29.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.toggle();
      });
    }
  });
  return (0, import_solid_js29.createComponent)(
    Button,
    (0, import_solid_js29.mergeProps)(
      (0, import_props15.omitProps)(props, ["children", "ref"]),
      CHECKBOX_INDICATOR,
      {
        id: context.indicatorID,
        role: "checkbox",
        "aria-labelledby": context.labelID,
        "aria-describedby": context.descriptionID,
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createCheckedState(() => state.checked()),
      {
        get children() {
          return (0, import_solid_js29.createComponent)(CheckStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/checkbox/CheckboxLabel.ts
var import_solid_js30 = require("solid-js");
var import_props16 = require("solid-use/props");
function CheckboxLabel(props) {
  const context = useCheckboxContext("CheckboxLabel");
  const state = useCheckState();
  return createDynamic(
    () => props.as || "label",
    (0, import_solid_js30.mergeProps)(
      (0, import_props16.omitProps)(props, ["as", "children"]),
      CHECKBOX_LABEL,
      {
        id: context.labelID,
        for: context.indicatorID,
        get children() {
          return (0, import_solid_js30.createComponent)(CheckStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createCheckedState(() => state.checked())
    )
  );
}

// src/components/color-scheme/index.ts
var import_solid_js31 = require("solid-js");
var import_media_query = require("solid-use/media-query");
var import_page_visibility = __toESM(require("solid-use/page-visibility"), 1);
var ColorSchemeContext = (0, import_solid_js31.createContext)();
var STORAGE_KEY = "theme-preference";
function ColorSchemeProvider(props) {
  let get;
  let set;
  if ("initialValue" in props) {
    const [scheme, setScheme] = (0, import_solid_js31.createSignal)(props.initialValue);
    get = scheme;
    set = (value) => {
      setScheme(value);
      if (props.onChange) {
        props.onChange(value);
      }
    };
  } else {
    get = () => props.value;
    set = (value) => {
      if (props.onChange) {
        props.onChange(value);
      }
    };
  }
  const prefersDark = (0, import_media_query.usePrefersDark)();
  const isVisible = (0, import_page_visibility.default)();
  const shouldToggle = (0, import_solid_js31.createMemo)(
    () => get() === "system" && prefersDark() || get() === "dark"
  );
  (0, import_solid_js31.createEffect)(() => {
    isVisible();
    const onChange = () => {
      const value = localStorage.getItem(STORAGE_KEY);
      if (value) {
        set(value);
      } else {
        set("system");
      }
    };
    onChange();
    use_event_listener_default(window, "storage", onChange, false);
  });
  (0, import_solid_js31.createEffect)(() => {
    localStorage.setItem(STORAGE_KEY, get());
  });
  (0, import_solid_js31.createEffect)(() => {
    document.documentElement.classList.toggle("dark", shouldToggle());
  });
  return (0, import_solid_js31.createComponent)(ColorSchemeContext.Provider, {
    value: {
      get value() {
        return get();
      },
      setValue(val) {
        set(val);
      },
      get preferred() {
        return shouldToggle() ? "dark" : "light";
      },
      get native() {
        return prefersDark() ? "dark" : "light";
      }
    },
    get children() {
      return props.children;
    }
  });
}
function useColorSchemeContext() {
  const ctx = (0, import_solid_js31.useContext)(ColorSchemeContext);
  assert(ctx, new Error("Missing <ColorSchemeProvider>"));
  return ctx;
}
function useColorScheme() {
  const ctx = useColorSchemeContext();
  return [() => ctx.value, ctx.setValue];
}
function useNativeColorScheme() {
  const ctx = useColorSchemeContext();
  return () => ctx.native;
}
function usePreferredColorScheme() {
  const ctx = useColorSchemeContext();
  return () => ctx.preferred;
}

// src/components/combobox/Combobox.ts
var import_solid_js35 = require("solid-js");
var import_props17 = require("solid-use/props");

// src/states/create-autocomplete-state.ts
var import_solid_js33 = require("solid-js");

// src/utils/create-input-reader.ts
var import_solid_js32 = require("solid-js");
var INPUT_READER_DEBOUNCE_TIMEOUT = 250;
function createInputReader(time = INPUT_READER_DEBOUNCE_TIMEOUT) {
  let timeout;
  (0, import_solid_js32.onCleanup)(() => {
    if (timeout) {
      clearTimeout(timeout);
    }
  });
  const [signal, setSignal] = (0, import_solid_js32.createSignal)("");
  return [
    signal,
    (value) => {
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        setSignal(value);
      }, time);
    }
  ];
}

// src/states/create-autocomplete-state.ts
function createSingleAutocompleteState(options) {
  const [active, setActive] = (0, import_solid_js33.createSignal)();
  let selectedValue;
  let setSelectedValue;
  const equals = options.by || isEqual;
  if ("defaultValue" in options) {
    const [selected, setSelected] = (0, import_solid_js33.createSignal)(
      options.defaultValue
    );
    selectedValue = selected;
    setSelectedValue = (value) => {
      setSelected(() => value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    selectedValue = (0, import_solid_js33.createMemo)(() => options.value);
    setSelectedValue = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = (0, import_solid_js33.createMemo)(() => !!options.disabled);
  const [input, setInput] = createInputReader();
  return {
    isSelected(value) {
      return isEqual(value, selectedValue());
    },
    select(value) {
      if (!(0, import_solid_js33.untrack)(isDisabled)) {
        if (options.toggleable && equals((0, import_solid_js33.untrack)(selectedValue), value)) {
          setSelectedValue(void 0);
        } else {
          setSelectedValue(value);
        }
      }
    },
    hasSelected() {
      return selectedValue() != null;
    },
    disabled: isDisabled,
    hasActive() {
      return !!active();
    },
    isActive(value) {
      const ref = active();
      return ref ? equals(value, ref.value) : false;
    },
    focus(value) {
      if (!(0, import_solid_js33.untrack)(isDisabled)) {
        setActive({
          value
        });
      }
    },
    blur() {
      if (!(0, import_solid_js33.untrack)(isDisabled)) {
        setActive(void 0);
      }
    },
    query() {
      return input();
    },
    setQuery(value) {
      if (!(0, import_solid_js33.untrack)(isDisabled)) {
        setInput(value);
      }
    },
    matches(value) {
      return options.matchBy(value, input());
    },
    hasQuery: (0, import_solid_js33.createMemo)(() => !!input())
  };
}
function createMultipleAutocompleteState(options) {
  const [active, setActive] = (0, import_solid_js33.createSignal)();
  let selectedValues;
  let setSelectedValues;
  const equals = options.by || isEqual;
  if ("defaultValue" in options) {
    const [selected, setSelected] = (0, import_solid_js33.createSignal)(options.defaultValue);
    selectedValues = selected;
    setSelectedValues = (value) => {
      setSelected(() => value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    selectedValues = (0, import_solid_js33.createMemo)(() => options.value);
    setSelectedValues = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = (0, import_solid_js33.createMemo)(() => !!options.disabled);
  const [input, setInput] = createInputReader();
  return {
    isSelected(value) {
      const values = selectedValues();
      for (let i = 0, len = values.length; i < len; i += 1) {
        if (equals(value, values[i])) {
          return true;
        }
      }
      return false;
    },
    select(value) {
      if (!(0, import_solid_js33.untrack)(isDisabled)) {
        const newValues = [];
        const currentValues = (0, import_solid_js33.untrack)(selectedValues);
        let hasValue = false;
        for (let i = 0, len = currentValues.length; i < len; i += 1) {
          const item = currentValues[i];
          const isSame = equals(item, value);
          if (isSame) {
            hasValue = true;
          }
          if (!(options.toggleable && isSame)) {
            newValues.push(item);
          }
        }
        if (!hasValue) {
          newValues.push(value);
        }
        setSelectedValues(newValues);
      }
    },
    hasSelected: (0, import_solid_js33.createMemo)(() => selectedValues().length > 0),
    disabled: isDisabled,
    hasActive: (0, import_solid_js33.createMemo)(() => !!active()),
    isActive(value) {
      const ref = active();
      if (ref) {
        return equals(value, ref.value);
      }
      return false;
    },
    focus(value) {
      if (!(0, import_solid_js33.untrack)(isDisabled)) {
        setActive({
          value
        });
      }
    },
    blur() {
      if (!(0, import_solid_js33.untrack)(isDisabled)) {
        setActive(void 0);
      }
    },
    query() {
      return input();
    },
    setQuery(value) {
      setInput(value);
    },
    matches(value) {
      return options.matchBy(value, input());
    },
    hasQuery: (0, import_solid_js33.createMemo)(() => !!input())
  };
}
var AutocompleteStateContext = (0, import_solid_js33.createContext)();
function AutocompleteStateProvider(props) {
  return (0, import_solid_js33.createComponent)(AutocompleteStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useAutocompleteState() {
  const ctx = (0, import_solid_js33.useContext)(AutocompleteStateContext);
  assert(ctx, new Error("Missing <AutocompleteStateProvider>"));
  return ctx;
}
function AutocompleteStateChild(props) {
  const state = useAutocompleteState();
  return (0, import_solid_js33.createMemo)(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return (0, import_solid_js33.createMemo)(() => current(state));
    }
    return current;
  });
}

// src/components/combobox/ComboboxContext.ts
var import_solid_js34 = require("solid-js");
var ComboboxContext = (0, import_solid_js34.createContext)();
function useComboboxContext(componentName) {
  const context = (0, import_solid_js34.useContext)(ComboboxContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Combobox>`)
  );
  return context;
}
function createComboboxOptionFocusNavigator() {
  return new FocusNavigator((0, import_solid_js34.createUniqueId)(), {
    virtual: true,
    base: MATCHES_NODE
  });
}

// src/components/combobox/tags.ts
var COMBOBOX_TAG = createTag("combobox");
var COMBOBOX_INPUT_TAG = createTag("combobox-input");
var COMBOBOX_OPTIONS_TAG = createTag("combobox-options");
var COMBOBOX_OPTION_TAG = createTag("combobox-option");
var COMBOBOX_LABEL_TAG = createTag("combobox-label");

// src/components/combobox/Combobox.ts
function isComboboxMultiple(props) {
  return !!props.multiple;
}
function isComboboxSelectUncontrolled(props) {
  return "defaultValue" in props;
}
function isComboboxDisclosureUncontrolled(props) {
  return "defaultOpen" in props;
}
function getProps(props) {
  if (isComboboxSelectUncontrolled(props)) {
    if (isComboboxDisclosureUncontrolled(props)) {
      return (0, import_props17.omitProps)(props, [
        "as",
        "by",
        "children",
        "defaultOpen",
        "defaultValue",
        "disabled",
        "matchBy",
        "multiple",
        "onClose",
        "onDisclosureChange",
        "onOpen",
        "onSelectChange",
        "toggleable"
      ]);
    }
    return (0, import_props17.omitProps)(props, [
      "as",
      "by",
      "children",
      "defaultValue",
      "disabled",
      "isOpen",
      "matchBy",
      "multiple",
      "onClose",
      "onDisclosureChange",
      "onOpen",
      "onSelectChange",
      "toggleable"
    ]);
  }
  if (isComboboxDisclosureUncontrolled(props)) {
    return (0, import_props17.omitProps)(props, [
      "as",
      "by",
      "children",
      "defaultOpen",
      "disabled",
      "matchBy",
      "multiple",
      "onClose",
      "onDisclosureChange",
      "onOpen",
      "onSelectChange",
      "toggleable",
      "value"
    ]);
  }
  return (0, import_props17.omitProps)(props, [
    "as",
    "by",
    "children",
    "disabled",
    "isOpen",
    "matchBy",
    "multiple",
    "onClose",
    "onDisclosureChange",
    "onOpen",
    "onSelectChange",
    "toggleable",
    "value"
  ]);
}
function Combobox(props) {
  return (0, import_solid_js35.createMemo)(() => {
    const labelID = (0, import_solid_js35.createUniqueId)();
    const inputID = (0, import_solid_js35.createUniqueId)();
    const optionsID = (0, import_solid_js35.createUniqueId)();
    const disclosureState = createDisclosureState(
      (0, import_solid_js35.mergeProps)(props, {
        onChange(value) {
          if (props.onDisclosureChange) {
            props.onDisclosureChange(value);
          }
        }
      })
    );
    const autocompleteState = isComboboxMultiple(props) ? createMultipleAutocompleteState(
      (0, import_solid_js35.mergeProps)(props, {
        onChange(value) {
          if (props.onSelectChange) {
            props.onSelectChange(value);
          }
        }
      })
    ) : createSingleAutocompleteState(
      (0, import_solid_js35.mergeProps)(props, {
        onChange(value) {
          if (props.onSelectChange) {
            props.onSelectChange(value);
          }
        }
      })
    );
    const controller = createComboboxOptionFocusNavigator();
    const [activeDescendant, setActiveDescendant] = (0, import_solid_js35.createSignal)();
    const [selectedDescendant, setSelectedDescendant] = (0, import_solid_js35.createSignal)(void 0, {
      equals: false
    });
    (0, import_solid_js35.createEffect)(() => {
      if (!autocompleteState.hasActive()) {
        setActiveDescendant(void 0);
      }
    });
    return (0, import_solid_js35.createComponent)(ComboboxContext.Provider, {
      value: {
        get multiple() {
          return props.multiple;
        },
        labelID,
        inputID,
        optionsID,
        controller,
        inputHovering: false,
        optionsHovering: false,
        get activeDescendant() {
          return activeDescendant();
        },
        set activeDescendant(value) {
          setActiveDescendant(value);
        },
        get selectedDescendant() {
          return selectedDescendant();
        },
        set selectedDescendant(value) {
          setSelectedDescendant(value);
        }
      },
      get children() {
        return (0, import_solid_js35.createComponent)(AutocompleteStateProvider, {
          state: autocompleteState,
          get children() {
            return (0, import_solid_js35.createComponent)(DisclosureStateProvider, {
              state: disclosureState,
              get children() {
                return createDynamic(
                  () => props.as || "div",
                  (0, import_solid_js35.mergeProps)(
                    getProps(props),
                    COMBOBOX_TAG,
                    {
                      "aria-labelledby": labelID,
                      get children() {
                        return props.children;
                      }
                    },
                    createDisabledState(() => autocompleteState.disabled()),
                    createARIADisabledState(() => autocompleteState.disabled()),
                    createHasSelectedState(
                      () => autocompleteState.hasSelected()
                    ),
                    createHasActiveState(() => autocompleteState.hasActive()),
                    createExpandedState(() => disclosureState.isOpen())
                  )
                );
              }
            });
          }
        });
      }
    });
  });
}

// src/components/combobox/ComboboxInput.ts
var import_solid_js36 = require("solid-js");
var import_props18 = require("solid-use/props");

// src/components/command/tags.ts
var COMMAND_TAG = createTag("command");
var COMMAND_INPUT_TAG = createTag("command-input");
var COMMAND_OPTIONS_TAG = createTag("command-options");
var COMMAND_OPTION_TAG = createTag("command-option");
var COMMAND_LABEL_TAG = createTag("command-label");

// src/components/combobox/ComboboxInput.ts
function ComboboxInput(props) {
  const context = useComboboxContext("ComboboxInput");
  const autocompleteState = useAutocompleteState();
  const disclosureState = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => autocompleteState.disabled() || props.disabled;
  (0, import_solid_js36.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      if (current instanceof HTMLInputElement) {
        use_event_listener_default(current, "input", () => {
          if (!isDisabled()) {
            autocompleteState.setQuery(current.value);
          }
        });
      }
      use_event_listener_default(current, "keydown", (e) => {
        if (!isDisabled()) {
          switch (e.key) {
            case "Escape": {
              disclosureState.close();
              break;
            }
            case "ArrowUp": {
              e.preventDefault();
              if (disclosureState.isOpen()) {
                context.controller.setPrevChecked(true);
              } else {
                disclosureState.open();
              }
              break;
            }
            case "ArrowDown": {
              e.preventDefault();
              if (disclosureState.isOpen()) {
                context.controller.setNextChecked(true);
              } else {
                disclosureState.open();
              }
              break;
            }
            case "Enter": {
              e.preventDefault();
              if (disclosureState.isOpen()) {
                context.selectedDescendant = context.activeDescendant;
              }
              break;
            }
            default:
              break;
          }
        }
      });
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          disclosureState.toggle();
        }
      });
      use_event_listener_default(current, "blur", (e) => {
        if (context.optionsHovering) {
          return;
        }
        autocompleteState.blur();
        if (!(e.relatedTarget && current.contains(e.relatedTarget))) {
          disclosureState.close();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.inputHovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.inputHovering = false;
      });
    }
  });
  (0, import_solid_js36.createEffect)(() => {
    if (autocompleteState.query() !== "") {
      if ((0, import_solid_js36.untrack)(() => disclosureState.isOpen())) {
        context.controller.setFirstChecked();
      } else {
        disclosureState.open();
      }
    }
  });
  (0, import_solid_js36.createEffect)(() => {
    if (context.activeDescendant) {
      const current = document.getElementById(context.activeDescendant);
      if (current) {
        context.controller.setCurrent(current);
      }
    }
  });
  return createDynamic(
    () => props.as || "input",
    (0, import_solid_js36.mergeProps)(
      (0, import_props18.omitProps)(props, ["as", "ref"]),
      {
        id: context.inputID,
        ref: setInternalRef,
        // Guarantee it's a text
        type: "text",
        // Guarantee it's interactive
        tabindex: 0,
        role: "combobox",
        // Controls the options listbox
        "aria-haspopup": "listbox",
        "aria-controls": context.optionsID,
        "aria-labelledby": context.labelID,
        get "aria-expanded"() {
          return disclosureState.isOpen();
        },
        get "aria-activedescendant"() {
          return context.activeDescendant;
        }
      },
      COMMAND_INPUT_TAG,
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createExpandedState(() => disclosureState.isOpen()),
      createARIAExpandedState(() => disclosureState.isOpen()),
      createHasSelectedState(() => autocompleteState.hasSelected()),
      createHasActiveState(() => autocompleteState.hasActive()),
      createHasQueryState(() => autocompleteState.hasQuery())
    )
  );
}

// src/components/combobox/ComboboxLabel.ts
var import_solid_js37 = require("solid-js");
var import_props19 = require("solid-use/props");
function ComboboxLabel(props) {
  const context = useComboboxContext("ComboboxLabel");
  const autocompleteState = useAutocompleteState();
  const disclosureState = useDisclosureState();
  return createDynamic(
    () => props.as || "label",
    (0, import_solid_js37.mergeProps)(
      (0, import_props19.omitProps)(props, ["as"]),
      COMBOBOX_LABEL_TAG,
      {
        id: context.labelID
      },
      createDisabledState(() => autocompleteState.disabled()),
      createExpandedState(() => disclosureState.isOpen()),
      createHasSelectedState(() => autocompleteState.hasSelected()),
      createHasActiveState(() => autocompleteState.hasActive()),
      createHasQueryState(() => autocompleteState.hasQuery())
    )
  );
}

// src/components/combobox/ComboboxOption.ts
var import_solid_js39 = require("solid-js");
var import_props20 = require("solid-use/props");

// src/states/create-autocomplete-option-state.ts
var import_solid_js38 = require("solid-js");
function createAutocompleteOptionState(options) {
  const state = useAutocompleteState();
  const isDisabled = (0, import_solid_js38.createMemo)(() => options.disabled || state.disabled());
  return {
    isSelected: (0, import_solid_js38.createMemo)(() => state.isSelected(options.value)),
    isActive: (0, import_solid_js38.createMemo)(() => state.isActive(options.value)),
    select() {
      if (!(0, import_solid_js38.untrack)(isDisabled)) {
        state.select(options.value);
      }
    },
    focus() {
      if (!(0, import_solid_js38.untrack)(isDisabled)) {
        state.focus(options.value);
      }
    },
    blur() {
      if (!(0, import_solid_js38.untrack)(isDisabled) && this.isActive()) {
        state.blur();
      }
    },
    matches: (0, import_solid_js38.createMemo)(() => state.matches(options.value)),
    disabled: isDisabled
  };
}
var AutocompleteOptionStateContext = (0, import_solid_js38.createContext)();
function AutocompleteOptionStateProvider(props) {
  return (0, import_solid_js38.createComponent)(AutocompleteOptionStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}

// src/components/combobox/ComboboxOption.ts
function ComboboxOption(props) {
  const context = useComboboxContext("ComboboxOptions");
  const disclosure = useDisclosureState();
  const state = createAutocompleteOptionState(props);
  const [internalRef, setInternalRef] = createForwardRef(props);
  const id = (0, import_solid_js39.createUniqueId)();
  (0, import_solid_js39.createEffect)(() => {
    if (!state.disabled() && context.selectedDescendant === id) {
      state.select();
      if (!context.multiple) {
        disclosure.close();
      }
    }
  });
  function focusOption() {
    context.activeDescendant = id;
    state.focus();
  }
  (0, import_solid_js39.createRenderEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!state.disabled()) {
          state.select();
          focusOption();
          if (!context.multiple) {
            disclosure.close();
          }
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        if (!state.disabled()) {
          focusOption();
        }
      });
      use_event_listener_default(current, "mouseleave", () => {
        state.blur();
      });
      useVirtualFocus((el) => {
        if (el === current) {
          focusOption();
        }
      });
    }
  });
  return (0, import_solid_js39.createComponent)(
    Button,
    (0, import_solid_js39.mergeProps)(
      (0, import_props20.omitProps)(props, ["as", "children", "disabled", "value", "ref"]),
      COMBOBOX_OPTION_TAG,
      createOwnerAttribute(context.controller.getId()),
      {
        id,
        get as() {
          return props.as || "li";
        },
        role: "option",
        tabindex: -1,
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      createMatchesState(() => state.matches()),
      {
        get children() {
          return (0, import_solid_js39.createComponent)(AutocompleteOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/combobox/ComboboxOptions.ts
var import_solid_js40 = require("solid-js");
var import_props21 = require("solid-use/props");
function ComboboxOptions(props) {
  const context = useComboboxContext("ComboboxOptions");
  const autocompleteState = useAutocompleteState();
  const disclosureState = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js40.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.controller.setRef(current);
      (0, import_solid_js40.onCleanup)(() => {
        context.controller.clearRef();
      });
      use_event_listener_default(current, "focusin", () => {
        if (context.anchor) {
          context.anchor.focus();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.optionsHovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.optionsHovering = false;
      });
    }
  });
  (0, import_solid_js40.createEffect)(() => {
    if (!disclosureState.isOpen()) {
      setInternalRef(void 0);
    }
  });
  (0, import_solid_js40.onMount)(() => {
    (0, import_solid_js40.createEffect)(() => {
      if (disclosureState.isOpen()) {
        if ((0, import_solid_js40.untrack)(() => autocompleteState.hasSelected())) {
          context.controller.setFirstChecked(SELECTED_NODE);
        } else {
          context.controller.setFirstChecked();
        }
      }
    });
  });
  return createUnmountable(
    props,
    () => disclosureState.isOpen(),
    () => createDynamic(
      () => props.as || "ul",
      (0, import_solid_js40.mergeProps)(
        (0, import_props21.omitProps)(props, ["as", "children", "ref"]),
        COMBOBOX_OPTIONS_TAG,
        {
          id: context.optionsID,
          role: "listbox",
          "aria-multiselectable": context.multiple,
          ref: setInternalRef,
          // TODO should Combobox support "horizontal"?
          "aria-orientation": "vertical",
          tabindex: -1
        },
        createDisabledState(() => autocompleteState.disabled()),
        createARIADisabledState(() => autocompleteState.disabled()),
        createExpandedState(() => disclosureState.isOpen()),
        createHasSelectedState(() => autocompleteState.hasSelected()),
        createHasActiveState(() => autocompleteState.hasActive()),
        createHasQueryState(() => autocompleteState.hasQuery()),
        {
          get children() {
            return (0, import_solid_js40.createComponent)(AutocompleteStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        }
      )
    )
  );
}

// src/components/command/Command.ts
var import_solid_js42 = require("solid-js");
var import_props22 = require("solid-use/props");

// src/components/command/CommandContext.ts
var import_solid_js41 = require("solid-js");
var CommandContext = (0, import_solid_js41.createContext)();
function useCommandContext(componentName) {
  const context = (0, import_solid_js41.useContext)(CommandContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Command>`)
  );
  return context;
}
function createCommandOptionFocusNavigator() {
  return new FocusNavigator((0, import_solid_js41.createUniqueId)(), {
    virtual: true,
    base: MATCHES_NODE
  });
}

// src/components/command/Command.ts
function isCommandMultiple(props) {
  return !!props.multiple;
}
function isCommandUncontrolled(props) {
  return "defaultValue" in props;
}
function Command(props) {
  return (0, import_solid_js42.createMemo)(() => {
    const controller = createCommandOptionFocusNavigator();
    const state = isCommandMultiple(props) ? createMultipleAutocompleteState(props) : createSingleAutocompleteState(props);
    const [activeDescendant, setActiveDescendant] = (0, import_solid_js42.createSignal)();
    const [selectedDescendant, setSelectedDescendant] = (0, import_solid_js42.createSignal)(void 0, {
      equals: false
    });
    const inputID = (0, import_solid_js42.createUniqueId)();
    const optionsID = (0, import_solid_js42.createUniqueId)();
    const labelID = (0, import_solid_js42.createUniqueId)();
    (0, import_solid_js42.createEffect)(() => {
      if (!state.hasActive()) {
        setActiveDescendant(void 0);
      }
    });
    return (0, import_solid_js42.createComponent)(CommandContext.Provider, {
      value: {
        multiple: !!props.multiple,
        controller,
        get activeDescendant() {
          return activeDescendant();
        },
        set activeDescendant(value) {
          setActiveDescendant(value);
        },
        get selectedDescendant() {
          return selectedDescendant();
        },
        set selectedDescendant(value) {
          setSelectedDescendant(value);
        },
        inputID,
        optionsID,
        labelID,
        optionsHovering: false
      },
      get children() {
        return createDynamic(
          () => props.as || "div",
          (0, import_solid_js42.mergeProps)(
            isCommandUncontrolled(props) ? (0, import_props22.omitProps)(props, [
              "as",
              "by",
              "children",
              "defaultValue",
              "disabled",
              "horizontal",
              "multiple",
              "onChange",
              "toggleable"
            ]) : (0, import_props22.omitProps)(props, [
              "as",
              "by",
              "children",
              "value",
              "disabled",
              "horizontal",
              "multiple",
              "onChange",
              "toggleable"
            ]),
            COMMAND_TAG,
            {
              id: controller.getId(),
              "aria-labelledby": labelID
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createHasSelectedState(() => state.hasSelected()),
            createHasActiveState(() => state.hasActive()),
            createHasQueryState(() => state.hasQuery()),
            {
              get children() {
                return (0, import_solid_js42.createComponent)(AutocompleteStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    });
  });
}

// src/components/command/CommandInput.ts
var import_solid_js43 = require("solid-js");
var import_props23 = require("solid-use/props");
function CommandInput(props) {
  const context = useCommandContext("CommandInput");
  const state = useAutocompleteState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => state.disabled() || props.disabled;
  (0, import_solid_js43.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      if (current instanceof HTMLInputElement) {
        use_event_listener_default(current, "input", () => {
          if (!isDisabled()) {
            state.setQuery(current.value);
          }
        });
      }
      use_event_listener_default(current, "keydown", (e) => {
        if (!isDisabled()) {
          switch (e.key) {
            case "ArrowUp": {
              e.preventDefault();
              context.controller.setPrevChecked(true);
              break;
            }
            case "ArrowDown": {
              e.preventDefault();
              context.controller.setNextChecked(true);
              break;
            }
            case "Enter": {
              e.preventDefault();
              context.selectedDescendant = context.activeDescendant;
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "focus", () => {
        if (context.activeDescendant) {
          const ref = document.getElementById(context.activeDescendant);
          if (ref) {
            context.controller.setCurrent(ref);
          }
        } else if (state.hasSelected()) {
          context.controller.setFirstChecked(SELECTED_NODE);
        } else {
          context.controller.setFirstChecked();
        }
      });
      use_event_listener_default(current, "blur", () => {
        if (!context.optionsHovering) {
          state.blur();
        }
      });
    }
  });
  (0, import_solid_js43.createEffect)(() => {
    if (state.query() !== "") {
      context.controller.setFirstChecked();
    }
  });
  (0, import_solid_js43.createEffect)(() => {
    if (context.activeDescendant) {
      const ref = document.getElementById(context.activeDescendant);
      if (ref) {
        context.controller.setCurrent(ref);
      }
    }
  });
  return createDynamic(
    () => props.as || "input",
    (0, import_solid_js43.mergeProps)(
      (0, import_props23.omitProps)(props, ["as", "ref"]),
      {
        id: context.inputID,
        ref: setInternalRef,
        // Guarantee it's a text
        type: "text",
        // Guarantee it's interactive
        tabindex: 0,
        role: "combobox",
        // Controls the options listbox
        "aria-controls": context.optionsID,
        // Since combobox roles have aria-expanded=false
        // as default but Command has a visible listbox
        // we set this to true
        "aria-expanded": true,
        get "aria-activedescendant"() {
          return context.activeDescendant;
        }
      },
      COMMAND_INPUT_TAG,
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createHasSelectedState(() => state.hasSelected()),
      createHasActiveState(() => state.hasActive()),
      createHasQueryState(() => state.hasQuery())
    )
  );
}

// src/components/command/CommandLabel.ts
var import_solid_js44 = require("solid-js");
var import_props24 = require("solid-use/props");
function CommandLabel(props) {
  const context = useCommandContext("CommandLabel");
  const state = useAutocompleteState();
  return createDynamic(
    () => props.as || "label",
    (0, import_solid_js44.mergeProps)(
      (0, import_props24.omitProps)(props, ["as"]),
      COMMAND_LABEL_TAG,
      {
        id: context.labelID
      },
      createDisabledState(() => state.disabled()),
      createHasSelectedState(() => state.hasSelected()),
      createHasActiveState(() => state.hasActive()),
      createHasQueryState(() => state.hasQuery())
    )
  );
}

// src/components/command/CommandOption.ts
var import_solid_js45 = require("solid-js");
var import_props25 = require("solid-use/props");
function CommandOption(props) {
  const context = useCommandContext("CommandOption");
  const [internalRef, setInternalRef] = createForwardRef(props);
  const state = createAutocompleteOptionState(props);
  const id = (0, import_solid_js45.createUniqueId)();
  (0, import_solid_js45.createEffect)(() => {
    if (!state.disabled() && context.selectedDescendant === id) {
      state.select();
    }
  });
  function focusOption() {
    context.activeDescendant = id;
    state.focus();
  }
  (0, import_solid_js45.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!state.disabled()) {
          state.select();
          focusOption();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        if (!state.disabled()) {
          focusOption();
        }
      });
      use_event_listener_default(current, "mouseleave", () => {
        state.blur();
      });
      useVirtualFocus((el) => {
        if (el === current) {
          focusOption();
        }
      });
    }
  });
  return (0, import_solid_js45.createComponent)(
    Button,
    (0, import_solid_js45.mergeProps)(
      (0, import_props25.omitProps)(props, ["as", "children", "value", "ref"]),
      COMMAND_OPTION_TAG,
      createOwnerAttribute(context.controller.getId()),
      {
        id,
        get as() {
          return props.as || "li";
        },
        role: "option",
        tabindex: -1,
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      createMatchesState(() => state.matches()),
      {
        get children() {
          return (0, import_solid_js45.createComponent)(AutocompleteOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/command/CommandOptions.ts
var import_solid_js46 = require("solid-js");
var import_props26 = require("solid-use/props");
function CommandOptions(props) {
  const context = useCommandContext("CommandOptions");
  const state = useAutocompleteState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js46.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.controller.setRef(current);
      (0, import_solid_js46.onCleanup)(() => {
        context.controller.clearRef();
      });
      use_event_listener_default(current, "focusin", () => {
        if (context.anchor) {
          context.anchor.focus();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.optionsHovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.optionsHovering = false;
      });
    }
  });
  return createDynamic(
    () => props.as || "ul",
    (0, import_solid_js46.mergeProps)(
      (0, import_props26.omitProps)(props, ["as", "children", "ref"]),
      COMMAND_OPTIONS_TAG,
      {
        id: context.optionsID,
        role: "listbox",
        "aria-multiselectable": context.multiple,
        ref: setInternalRef,
        // TODO should Command support "horizontal"?
        "aria-orientation": "vertical",
        tabindex: -1
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createHasSelectedState(() => state.hasSelected()),
      createHasActiveState(() => state.hasActive()),
      createHasQueryState(() => state.hasQuery()),
      {
        get children() {
          return (0, import_solid_js46.createComponent)(AutocompleteStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/command-bar/CommandBar.ts
var import_solid_js48 = require("solid-js");
var import_props27 = require("solid-use/props");

// src/components/command-bar/CommandBarContext.ts
var import_solid_js47 = require("solid-js");
var CommandBarContext = (0, import_solid_js47.createContext)();
function useCommandBarContext(componentName) {
  const context = (0, import_solid_js47.useContext)(CommandBarContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <CommandBar>`)
  );
  return context;
}

// src/components/command-bar/tags.ts
var COMMAND_BAR_TAG = createTag("command-bar");
var COMMAND_BAR_DESCRIPTION_TAG = createTag("command-bar-description");
var COMMAND_BAR_OVERLAY_TAG = createTag("command-bar-overlay");
var COMMAND_BAR_PANEL_TAG = createTag("command-bar-panel");
var COMMAND_BAR_TITLE_TAG = createTag("command-bar-title");

// src/components/command-bar/CommandBar.ts
function isCommandBarUncontrolled(props) {
  return "defaultOpen" in props;
}
function CommandBar(props) {
  const ownerID = (0, import_solid_js48.createUniqueId)();
  const panelID = (0, import_solid_js48.createUniqueId)();
  const titleID = (0, import_solid_js48.createUniqueId)();
  const descriptionID = (0, import_solid_js48.createUniqueId)();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  (0, import_solid_js48.createEffect)(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  (0, import_solid_js48.createEffect)(() => {
    use_event_listener_default(window, "keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "k" && !e.defaultPrevented) {
        e.preventDefault();
        state.open();
      }
    });
  });
  return (0, import_solid_js48.createComponent)(CommandBarContext.Provider, {
    value: {
      ownerID,
      panelID,
      titleID,
      descriptionID
    },
    get children() {
      return createUnmountable(
        props,
        () => state.isOpen(),
        () => createDynamic(
          () => props.as || "div",
          (0, import_solid_js48.mergeProps)(
            isCommandBarUncontrolled(props) ? (0, import_props27.omitProps)(props, [
              "as",
              "children",
              "defaultOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]) : (0, import_props27.omitProps)(props, [
              "as",
              "children",
              "isOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]),
            {
              id: ownerID,
              role: "dialog",
              "aria-modal": true,
              "aria-labelledby": titleID,
              "aria-describedby": descriptionID
            },
            COMMAND_BAR_TAG,
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createExpandedState(() => state.isOpen()),
            {
              get children() {
                return (0, import_solid_js48.createComponent)(DisclosureStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        )
      );
    }
  });
}

// src/components/command-bar/CommandBarDescription.ts
var import_solid_js49 = require("solid-js");
var import_props28 = require("solid-use/props");
function CommandBarDescription(props) {
  const context = useCommandBarContext("CommandBarDescription");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "p",
    (0, import_solid_js49.mergeProps)(
      (0, import_props28.omitProps)(props, ["as", "children"]),
      COMMAND_BAR_DESCRIPTION_TAG,
      {
        id: context.descriptionID,
        get children() {
          return (0, import_solid_js49.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/command-bar/CommandBarOverlay.ts
var import_solid_js50 = require("solid-js");
var import_props29 = require("solid-use/props");
function CommandBarOverlay(props) {
  useCommandBarContext("CommandBarOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js50.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js50.mergeProps)(
      (0, import_props29.omitProps)(props, ["as", "children", "ref"]),
      COMMAND_BAR_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return (0, import_solid_js50.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/command-bar/CommandBarPanel.ts
var import_solid_js51 = require("solid-js");
var import_props30 = require("solid-use/props");
function CommandBarPanel(props) {
  const context = useCommandBarContext("CommandBarPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js51.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      if (state.isOpen()) {
        focusFirst(getFocusableElements(current), false);
        use_event_listener_default(current, "keydown", (e) => {
          if (!props.disabled) {
            switch (e.key) {
              case "Tab": {
                e.preventDefault();
                lockFocus(current, e.shiftKey, false);
                break;
              }
              case "Escape": {
                state.close();
                break;
              }
              default:
                break;
            }
          }
        });
      }
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js51.mergeProps)(
      (0, import_props30.omitProps)(props, ["as", "children", "ref"]),
      COMMAND_BAR_PANEL_TAG,
      {
        id: context.panelID,
        ref: setInternalRef,
        get children() {
          return (0, import_solid_js51.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/command-bar/CommandBarTitle.ts
var import_solid_js52 = require("solid-js");
var import_props31 = require("solid-use/props");
function CommandBarTitle(props) {
  const context = useCommandBarContext("CommandBarTitle");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "h2",
    (0, import_solid_js52.mergeProps)(
      (0, import_props31.omitProps)(props, ["as", "children"]),
      COMMAND_BAR_TITLE_TAG,
      {
        id: context.titleID,
        get children() {
          return (0, import_solid_js52.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/context-menu/ContextMenu.ts
var import_solid_js54 = require("solid-js");
var import_props32 = require("solid-use/props");

// src/components/context-menu/ContextMenuContext.ts
var import_solid_js53 = require("solid-js");
var ContextMenuContext = (0, import_solid_js53.createContext)();
function useContextMenuContext(componentName) {
  const context = (0, import_solid_js53.useContext)(ContextMenuContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <ContextMenu>`)
  );
  return context;
}

// src/components/context-menu/tags.ts
var CONTEXT_MENU_TAG = createTag("context-menu");
var CONTEXT_MENU_BOUNDARY_TAG = createTag("context-menu-boundary");
var CONTEXT_MENU_OVERLAY_TAG = createTag("context-menu-overlay");
var CONTEXT_MENU_PANEL_TAG = createTag("context-menu-panel");

// src/components/context-menu/ContextMenu.ts
function isContextMenuUncontrolled(props) {
  return "defaultOpen" in props;
}
function ContextMenu(props) {
  const ownerID = (0, import_solid_js54.createUniqueId)();
  const boundaryID = (0, import_solid_js54.createUniqueId)();
  const panelID = (0, import_solid_js54.createUniqueId)();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  (0, import_solid_js54.createEffect)(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  return (0, import_solid_js54.createComponent)(ContextMenuContext.Provider, {
    value: {
      ownerID,
      boundaryID,
      panelID
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js54.mergeProps)(
          isContextMenuUncontrolled(props) ? (0, import_props32.omitProps)(props, [
            "as",
            "children",
            "defaultOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]) : (0, import_props32.omitProps)(props, [
            "as",
            "children",
            "isOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]),
          CONTEXT_MENU_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createExpandedState(() => state.isOpen()),
          {
            get children() {
              return (0, import_solid_js54.createComponent)(DisclosureStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/context-menu/ContextMenuBoundary.ts
var import_solid_js55 = require("solid-js");
var import_props33 = require("solid-use/props");
function ContextMenuBoundary(props) {
  const context = useContextMenuContext("ContextMenuBoundary");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js55.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      use_event_listener_default(current, "contextmenu", (e) => {
        if (!state.disabled()) {
          e.preventDefault();
          state.open();
        }
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js55.mergeProps)(
      (0, import_props33.omitProps)(props, ["as", "children", "ref"]),
      CONTEXT_MENU_BOUNDARY_TAG,
      {
        id: context.boundaryID,
        ref: setInternalRef,
        get "aria-controls"() {
          return state.isOpen() && context.panelID;
        }
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen()),
      createARIAExpandedState(() => state.isOpen()),
      {
        get children() {
          return (0, import_solid_js55.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/context-menu/ContextMenuOverlay.ts
var import_solid_js56 = require("solid-js");
var import_props34 = require("solid-use/props");
function ContextMenuOverlay(props) {
  useContextMenuContext("ContextMenuOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js56.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js56.mergeProps)(
      (0, import_props34.omitProps)(props, ["as", "children", "ref"]),
      CONTEXT_MENU_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return (0, import_solid_js56.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/context-menu/ContextMenuPanel.ts
var import_solid_js57 = require("solid-js");
var import_props35 = require("solid-use/props");
function ContextMenuPanel(props) {
  const context = useContextMenuContext("ContextMenuPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js57.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      if (state.isOpen()) {
        focusFirst(getFocusableElements(current), false);
        use_event_listener_default(current, "keydown", (e) => {
          if (!props.disabled) {
            switch (e.key) {
              case "Tab": {
                e.preventDefault();
                lockFocus(current, e.shiftKey, false);
                break;
              }
              case "Escape": {
                state.close();
                break;
              }
              default:
                break;
            }
          }
        });
        use_event_listener_default(document, "click", (e) => {
          if (!current.contains(e.target)) {
            state.close();
          }
        });
      }
    }
  });
  return createUnmountable(
    props,
    () => state.isOpen(),
    () => createDynamic(
      () => props.as || "div",
      (0, import_solid_js57.mergeProps)(
        (0, import_props35.omitProps)(props, ["as", "unmount", "children", "ref"]),
        CONTEXT_MENU_PANEL_TAG,
        {
          id: context.panelID,
          ref: setInternalRef,
          get children() {
            return (0, import_solid_js57.createComponent)(DisclosureStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        },
        createDisabledState(() => state.disabled()),
        createExpandedState(() => state.isOpen())
      )
    )
  );
}

// src/components/dialog/Dialog.ts
var import_solid_js59 = require("solid-js");
var import_props36 = require("solid-use/props");

// src/components/dialog/DialogContext.ts
var import_solid_js58 = require("solid-js");
var DialogContext = (0, import_solid_js58.createContext)();
function useDialogContext(componentName) {
  const context = (0, import_solid_js58.useContext)(DialogContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Dialog>`)
  );
  return context;
}

// src/components/dialog/tags.ts
var DIALOG_TAG = createTag("dialog");
var DIALOG_DESCRIPTION_TAG = createTag("dialog-description");
var DIALOG_OVERLAY_TAG = createTag("dialog-overlay");
var DIALOG_PANEL_TAG = createTag("dialog-panel");
var DIALOG_TITLE_TAG = createTag("dialog-title");

// src/components/dialog/Dialog.ts
function isDialogUncontrolled(props) {
  return "defaultOpen" in props;
}
function Dialog(props) {
  const ownerID = (0, import_solid_js59.createUniqueId)();
  const panelID = (0, import_solid_js59.createUniqueId)();
  const titleID = (0, import_solid_js59.createUniqueId)();
  const descriptionID = (0, import_solid_js59.createUniqueId)();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  (0, import_solid_js59.createEffect)(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  return (0, import_solid_js59.createComponent)(DialogContext.Provider, {
    value: {
      ownerID,
      panelID,
      titleID,
      descriptionID
    },
    get children() {
      return createUnmountable(
        props,
        () => state.isOpen(),
        () => createDynamic(
          () => props.as || "div",
          (0, import_solid_js59.mergeProps)(
            isDialogUncontrolled(props) ? (0, import_props36.omitProps)(props, [
              "as",
              "children",
              "defaultOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]) : (0, import_props36.omitProps)(props, [
              "as",
              "children",
              "isOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]),
            DIALOG_TAG,
            {
              id: ownerID,
              role: "dialog",
              "aria-modal": true,
              "aria-labelledby": titleID,
              "aria-describedby": descriptionID,
              get children() {
                return (0, import_solid_js59.createComponent)(DisclosureStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createExpandedState(() => state.isOpen())
          )
        )
      );
    }
  });
}

// src/components/dialog/DialogDescription.ts
var import_solid_js60 = require("solid-js");
var import_props37 = require("solid-use/props");
function DialogDescription(props) {
  const context = useDialogContext("DialogDescription");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "p",
    (0, import_solid_js60.mergeProps)(
      (0, import_props37.omitProps)(props, ["as", "children"]),
      DIALOG_DESCRIPTION_TAG,
      {
        id: context.descriptionID,
        get children() {
          return (0, import_solid_js60.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/dialog/DialogOverlay.ts
var import_solid_js61 = require("solid-js");
var import_props38 = require("solid-use/props");
function DialogOverlay(props) {
  useDialogContext("DialogOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js61.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js61.mergeProps)(
      (0, import_props38.omitProps)(props, ["as", "children", "ref"]),
      DIALOG_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return (0, import_solid_js61.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/dialog/DialogPanel.ts
var import_solid_js62 = require("solid-js");
var import_props39 = require("solid-use/props");
function DialogPanel(props) {
  const context = useDialogContext("DialogPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js62.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement && state.isOpen()) {
      focusFirst(getFocusableElements(current), false);
      use_event_listener_default(current, "keydown", (e) => {
        if (!props.disabled) {
          switch (e.key) {
            case "Tab": {
              e.preventDefault();
              lockFocus(current, e.shiftKey, false);
              break;
            }
            case "Escape": {
              state.close();
              break;
            }
            default:
              break;
          }
        }
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js62.mergeProps)(
      (0, import_props39.omitProps)(props, ["as", "children", "ref"]),
      DIALOG_PANEL_TAG,
      {
        id: context.panelID,
        ref: setInternalRef,
        get children() {
          return (0, import_solid_js62.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/dialog/DialogTitle.ts
var import_solid_js63 = require("solid-js");
var import_props40 = require("solid-use/props");
function DialogTitle(props) {
  const context = useDialogContext("DialogTitle");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "h2",
    (0, import_solid_js63.mergeProps)(
      (0, import_props40.omitProps)(props, ["as", "children"]),
      DIALOG_TITLE_TAG,
      {
        id: context.titleID,
        get children() {
          return (0, import_solid_js63.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/disclosure/Disclosure.ts
var import_solid_js65 = require("solid-js");
var import_props41 = require("solid-use/props");

// src/components/disclosure/DisclosureContext.ts
var import_solid_js64 = require("solid-js");
var DisclosureContext = (0, import_solid_js64.createContext)();
function useDisclosureContext(componentName) {
  const context = (0, import_solid_js64.useContext)(DisclosureContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Disclosure>`)
  );
  return context;
}

// src/components/disclosure/tags.ts
var DISCLOSURE_TAG = createTag("disclosure");
var DISCLOSURE_BUTTON_TAG = createTag("disclosure-button");
var DISCLOSURE_PANEL_TAG = createTag("disclosure-panel");

// src/components/disclosure/Disclosure.ts
function isDisclosureUncontrolled(props) {
  return "defaultOpen" in props;
}
function Disclosure(props) {
  const ownerID = (0, import_solid_js65.createUniqueId)();
  const buttonID = (0, import_solid_js65.createUniqueId)();
  const panelID = (0, import_solid_js65.createUniqueId)();
  const state = createDisclosureState(props);
  return (0, import_solid_js65.createComponent)(DisclosureContext.Provider, {
    value: {
      ownerID,
      buttonID,
      panelID
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js65.mergeProps)(
          isDisclosureUncontrolled(props) ? (0, import_props41.omitProps)(props, [
            "as",
            "children",
            "defaultOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]) : (0, import_props41.omitProps)(props, [
            "as",
            "children",
            "isOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]),
          DISCLOSURE_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createExpandedState(() => state.isOpen()),
          {
            get children() {
              return (0, import_solid_js65.createComponent)(DisclosureStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/disclosure/DisclosureButton.ts
var import_solid_js66 = require("solid-js");
var import_web3 = require("solid-js/web");
var import_props42 = require("solid-use/props");
function DisclosureButton(props) {
  const context = useDisclosureContext("DisclosureButton");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => state.disabled() || props.disabled;
  (0, import_solid_js66.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          state.toggle();
        }
      });
    }
  });
  return (0, import_web3.createComponent)(
    Button,
    (0, import_solid_js66.mergeProps)(
      (0, import_props42.omitProps)(props, ["children", "ref"]),
      DISCLOSURE_BUTTON_TAG,
      {
        id: context.buttonID,
        ref: setInternalRef,
        get "aria-controls"() {
          return state.isOpen() && context.panelID;
        }
      },
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createExpandedState(() => state.isOpen()),
      createARIAExpandedState(() => state.isOpen()),
      {
        get children() {
          return (0, import_web3.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/disclosure/DisclosurePanel.ts
var import_solid_js67 = require("solid-js");
var import_props43 = require("solid-use/props");
function DisclosurePanel(props) {
  const context = useDisclosureContext("DisclosurePanel");
  const state = useDisclosureState();
  return createUnmountable(
    props,
    () => state.isOpen(),
    () => createDynamic(
      () => props.as || "div",
      (0, import_solid_js67.mergeProps)(
        (0, import_props43.omitProps)(props, ["as", "unmount", "children"]),
        DISCLOSURE_PANEL_TAG,
        {
          id: context.panelID,
          get children() {
            return (0, import_solid_js67.createComponent)(DisclosureStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        },
        createDisabledState(() => state.disabled()),
        createExpandedState(() => state.isOpen())
      )
    )
  );
}

// src/components/feed/Feed.ts
var import_solid_js69 = require("solid-js");
var import_props44 = require("solid-use/props");

// src/components/feed/FeedContext.ts
var import_solid_js68 = require("solid-js");
var FeedContext = (0, import_solid_js68.createContext)();
function useFeedContext(componentName) {
  const context = (0, import_solid_js68.useContext)(FeedContext);
  assert(context, new Error(`<${componentName}> must be used inside a <Feed>`));
  return context;
}

// src/components/feed/tags.ts
var FEED_TAG = createTag("feed");
var FEED_ARTICLE_TAG = createTag("feed-article");
var FEED_ARTICLE_DESCRIPTION_TAG = createTag(
  "feed-article-description"
);
var FEED_ARTICLE_LABEL_TAG = createTag("feed-article-label");
var FEED_CONTENT_TAG = createTag("feed-content");
var FEED_LABEL_TAG = createTag("feed-label");

// src/components/feed/Feed.ts
function Feed(props) {
  const ownerID = (0, import_solid_js69.createUniqueId)();
  const labelID = (0, import_solid_js69.createUniqueId)();
  const contentID = (0, import_solid_js69.createUniqueId)();
  const [ref, setRef] = createForwardRef(props);
  return (0, import_solid_js69.createComponent)(FeedContext.Provider, {
    value: {
      ownerID,
      labelID,
      contentID,
      get size() {
        return props.size;
      },
      get busy() {
        return !!props.busy;
      },
      focusNext() {
        const current = ref();
        if (current instanceof HTMLElement) {
          focusNext(
            getFocusableElements(document.documentElement),
            current,
            false,
            false
          );
        }
      },
      focusPrev() {
        const current = ref();
        if (current instanceof HTMLElement) {
          focusPrev(
            getFocusableElements(document.documentElement),
            current,
            false,
            false
          );
        }
      }
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js69.mergeProps)((0, import_props44.omitProps)(props, ["as", "busy", "size"]), FEED_TAG, {
          id: ownerID,
          ref: setRef
        })
      );
    }
  });
}

// src/components/feed/FeedArticle.ts
var import_solid_js71 = require("solid-js");
var import_props45 = require("solid-use/props");

// src/components/feed/FeedArticleContext.ts
var import_solid_js70 = require("solid-js");
var FeedArticleContext = (0, import_solid_js70.createContext)();
function useFeedArticleContext(componentName) {
  const context = (0, import_solid_js70.useContext)(FeedArticleContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <FeedArticle>`)
  );
  return context;
}

// src/components/feed/FeedArticle.ts
function FeedArticle(props) {
  const rootContext = useFeedContext("FeedArticle");
  const ownerID = (0, import_solid_js71.createUniqueId)();
  const labelID = (0, import_solid_js71.createUniqueId)();
  const descriptionID = (0, import_solid_js71.createUniqueId)();
  return (0, import_solid_js71.createComponent)(FeedArticleContext.Provider, {
    value: {
      ownerID,
      labelID,
      descriptionID
    },
    get children() {
      return createDynamic(
        () => props.as || "article",
        (0, import_solid_js71.mergeProps)(
          (0, import_props45.omitProps)(props, ["as"]),
          FEED_ARTICLE_TAG,
          createOwnerAttribute(rootContext.ownerID),
          {
            id: ownerID,
            "aria-labelledby": labelID,
            "aria-describedby": descriptionID,
            tabindex: 0,
            get "aria-posinset"() {
              return props.index + 1;
            },
            get "aria-setsize"() {
              return rootContext.size;
            }
          }
        )
      );
    }
  });
}

// src/components/feed/FeedArticleDescription.ts
var import_solid_js72 = require("solid-js");
var import_props46 = require("solid-use/props");
function FeedArticleDescription(props) {
  const context = useFeedArticleContext("FeedArticleDescription");
  return createDynamic(
    () => props.as || "p",
    (0, import_solid_js72.mergeProps)((0, import_props46.omitProps)(props, ["as"]), FEED_ARTICLE_DESCRIPTION_TAG, {
      id: context.descriptionID
    })
  );
}

// src/components/feed/FeedArticleLabel.ts
var import_solid_js73 = require("solid-js");
var import_props47 = require("solid-use/props");
function FeedArticleLabel(props) {
  const context = useFeedArticleContext("FeedArticleLabel");
  return createDynamic(
    () => props.as || "span",
    (0, import_solid_js73.mergeProps)((0, import_props47.omitProps)(props, ["as"]), FEED_ARTICLE_LABEL_TAG, {
      id: context.labelID
    })
  );
}

// src/components/feed/FeedContent.ts
var import_solid_js75 = require("solid-js");
var import_props48 = require("solid-use/props");

// src/components/feed/FeedContentContext.ts
var import_solid_js74 = require("solid-js");
var FeedContentContext = (0, import_solid_js74.createContext)();
function createFeedArticleFocusNavigator(owner) {
  return new FocusNavigator(owner);
}

// src/components/feed/FeedContent.ts
function FeedContent(props) {
  const context = useFeedContext("FeedContent");
  const controller = createFeedArticleFocusNavigator(context.ownerID);
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js75.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      controller.setRef(current);
      (0, import_solid_js75.onCleanup)(() => {
        controller.clearRef();
      });
      use_event_listener_default(current, "keydown", (e) => {
        if (e.ctrlKey) {
          switch (e.key) {
            case "Home": {
              e.preventDefault();
              context.focusPrev();
              break;
            }
            case "End": {
              e.preventDefault();
              context.focusNext();
              break;
            }
            default:
              break;
          }
        }
        switch (e.key) {
          case "PageUp": {
            e.preventDefault();
            controller.setPrevChecked(false);
            break;
          }
          case "PageDown": {
            e.preventDefault();
            controller.setNextChecked(false);
            break;
          }
          default:
            break;
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          controller.setCurrent(e.target);
        }
      });
    }
  });
  return (0, import_solid_js75.createComponent)(FeedContentContext.Provider, {
    value: controller,
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js75.mergeProps)((0, import_props48.omitProps)(props, ["as"]), FEED_CONTENT_TAG, {
          id: context.contentID,
          role: "feed",
          "aria-labelledby": context.labelID,
          get "aria-busy"() {
            return context.busy;
          },
          ref: setInternalRef
        })
      );
    }
  });
}

// src/components/feed/FeedLabel.ts
var import_solid_js76 = require("solid-js");
var import_props49 = require("solid-use/props");
function FeedLabel(props) {
  const context = useFeedContext("FeedLabel");
  return createDynamic(
    () => props.as || "span",
    (0, import_solid_js76.mergeProps)((0, import_props49.omitProps)(props, ["as"]), FEED_LABEL_TAG, {
      id: context.labelID
    })
  );
}

// src/components/listbox/Listbox.ts
var import_solid_js78 = require("solid-js");
var import_props50 = require("solid-use/props");

// src/components/listbox/ListboxContext.ts
var import_solid_js77 = require("solid-js");
var ListboxContext = (0, import_solid_js77.createContext)();
function useListboxContext(componentName) {
  const context = (0, import_solid_js77.useContext)(ListboxContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Listbox>`)
  );
  return context;
}

// src/components/listbox/tags.ts
var LISTBOX_TAG = createTag("listbox");
var LISTBOX_BUTTON_TAG = createTag("listbox-button");
var LISTBOX_LABEL_TAG = createTag("listbox-label");
var LISTBOX_OPTIONS_TAG = createTag("listbox-options");
var LISTBOX_OPTION_TAG = createTag("listbox-option");

// src/components/listbox/Listbox.ts
function isListboxMultiple(props) {
  return !!props.multiple;
}
function isListboxSelectUncontrolled(props) {
  return "defaultValue" in props;
}
function isListboxDisclosureUncontrolled(props) {
  return "defaultOpen" in props;
}
function getProps2(props) {
  if (isListboxSelectUncontrolled(props)) {
    if (isListboxDisclosureUncontrolled(props)) {
      return (0, import_props50.omitProps)(props, [
        "as",
        "by",
        "children",
        "defaultOpen",
        "defaultValue",
        "disabled",
        "horizontal",
        "multiple",
        "onClose",
        "onDisclosureChange",
        "onOpen",
        "onSelectChange",
        "toggleable"
      ]);
    }
    return (0, import_props50.omitProps)(props, [
      "as",
      "by",
      "children",
      "isOpen",
      "defaultValue",
      "disabled",
      "horizontal",
      "multiple",
      "onClose",
      "onDisclosureChange",
      "onOpen",
      "onSelectChange",
      "toggleable"
    ]);
  }
  if (isListboxDisclosureUncontrolled(props)) {
    return (0, import_props50.omitProps)(props, [
      "as",
      "by",
      "children",
      "defaultOpen",
      "value",
      "disabled",
      "horizontal",
      "multiple",
      "onClose",
      "onDisclosureChange",
      "onOpen",
      "onSelectChange",
      "toggleable"
    ]);
  }
  return (0, import_props50.omitProps)(props, [
    "as",
    "by",
    "children",
    "isOpen",
    "value",
    "disabled",
    "horizontal",
    "multiple",
    "onClose",
    "onDisclosureChange",
    "onOpen",
    "onSelectChange",
    "toggleable"
  ]);
}
function Listbox(props) {
  return (0, import_solid_js78.createMemo)(() => {
    const ownerID = (0, import_solid_js78.createUniqueId)();
    const labelID = (0, import_solid_js78.createUniqueId)();
    const buttonID = (0, import_solid_js78.createUniqueId)();
    const optionsID = (0, import_solid_js78.createUniqueId)();
    const disclosureState = createDisclosureState(
      (0, import_solid_js78.mergeProps)(props, {
        onChange(value) {
          if (props.onDisclosureChange) {
            props.onDisclosureChange(value);
          }
        }
      })
    );
    const selectState = isListboxMultiple(props) ? createMultipleSelectState(
      (0, import_solid_js78.mergeProps)(props, {
        onChange(value) {
          if (props.onSelectChange) {
            props.onSelectChange(value);
          }
        }
      })
    ) : createSingleSelectState(
      (0, import_solid_js78.mergeProps)(props, {
        onChange(value) {
          if (props.onSelectChange) {
            props.onSelectChange(value);
          }
        }
      })
    );
    const fsp = useFocusStartPoint();
    (0, import_solid_js78.createEffect)(() => {
      if (disclosureState.isOpen()) {
        fsp.save();
      } else {
        fsp.load();
      }
    });
    return (0, import_solid_js78.createComponent)(ListboxContext.Provider, {
      value: {
        get multiple() {
          return props.multiple;
        },
        ownerID,
        labelID,
        buttonID,
        optionsID,
        get horizontal() {
          return props.horizontal;
        },
        buttonHovering: false,
        optionsHovering: false
      },
      get children() {
        return (0, import_solid_js78.createComponent)(SelectStateProvider, {
          state: selectState,
          get children() {
            return (0, import_solid_js78.createComponent)(DisclosureStateProvider, {
              state: disclosureState,
              get children() {
                return createDynamic(
                  () => props.as || "div",
                  (0, import_solid_js78.mergeProps)(
                    getProps2(props),
                    LISTBOX_TAG,
                    {
                      id: ownerID,
                      "aria-labelledby": labelID
                    },
                    createDisabledState(() => selectState.disabled()),
                    createARIADisabledState(() => selectState.disabled()),
                    createHasSelectedState(() => selectState.hasSelected()),
                    createHasActiveState(() => selectState.hasActive()),
                    createExpandedState(() => disclosureState.isOpen()),
                    {
                      get children() {
                        return props.children;
                      }
                    }
                  )
                );
              }
            });
          }
        });
      }
    });
  });
}

// src/components/listbox/ListboxButton.ts
var import_solid_js79 = require("solid-js");
var import_props51 = require("solid-use/props");
function ListboxButton(props) {
  const context = useListboxContext("ListboxButton");
  const disclosureState = useDisclosureState();
  const selectState = useSelectState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => disclosureState.disabled() || props.disabled;
  (0, import_solid_js79.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          disclosureState.toggle();
        }
      });
      use_event_listener_default(current, "keydown", (e) => {
        if (!isDisabled()) {
          switch (e.key) {
            case "ArrowUp":
            case "ArrowDown": {
              e.preventDefault();
              disclosureState.toggle();
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.buttonHovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.buttonHovering = false;
      });
    }
  });
  return (0, import_solid_js79.createComponent)(
    Button,
    (0, import_solid_js79.mergeProps)(
      (0, import_props51.omitProps)(props, ["children", "ref"]),
      LISTBOX_BUTTON_TAG,
      {
        id: context.buttonID,
        "aria-haspopup": "listbox",
        "aria-controls": context.optionsID,
        ref: setInternalRef
      },
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createExpandedState(() => disclosureState.isOpen()),
      createARIAExpandedState(() => disclosureState.isOpen()),
      createHasSelectedState(() => selectState.hasSelected()),
      createHasActiveState(() => selectState.hasActive()),
      {
        get children() {
          return (0, import_solid_js79.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/listbox/ListboxLabel.ts
var import_solid_js80 = require("solid-js");
var import_props52 = require("solid-use/props");
function ListboxLabel(props) {
  const context = useListboxContext("ListboxLabel");
  const disclosureState = useDisclosureState();
  const selectState = useSelectState();
  return createDynamic(
    () => props.as || "label",
    (0, import_solid_js80.mergeProps)(
      (0, import_props52.omitProps)(props, ["as", "children"]),
      LISTBOX_LABEL_TAG,
      {
        id: context.labelID,
        get children() {
          return (0, import_solid_js80.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => disclosureState.disabled()),
      createExpandedState(() => disclosureState.isOpen()),
      createHasSelectedState(() => selectState.hasSelected()),
      createHasActiveState(() => selectState.hasActive())
    )
  );
}

// src/components/listbox/ListboxOption.ts
var import_solid_js82 = require("solid-js");
var import_props53 = require("solid-use/props");

// src/components/listbox/ListboxOptionsContext.ts
var import_solid_js81 = require("solid-js");
var ListboxOptionsContext = (0, import_solid_js81.createContext)();
function useListboxOptionsContext(componentName) {
  const context = (0, import_solid_js81.useContext)(ListboxOptionsContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <ListboxOptions>`)
  );
  return context;
}
function createListboxOptionsFocusNavigator(owner) {
  return new FocusNavigator(owner);
}

// src/components/listbox/ListboxOption.ts
function ListboxOption(props) {
  const rootContext = useListboxContext("ListboxOptions");
  const context = useListboxOptionsContext("ListboxOptions");
  const disclosure = useDisclosureState();
  const state = createSelectOptionState(props);
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js82.createRenderEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!state.disabled()) {
          state.select();
          if (!rootContext.multiple) {
            disclosure.close();
          }
        }
      });
      use_event_listener_default(current, "focus", () => {
        state.focus();
      });
      use_event_listener_default(current, "blur", () => {
        state.blur();
      });
      use_event_listener_default(current, "mouseenter", () => {
        if (!state.disabled()) {
          current.focus();
        }
      });
      use_event_listener_default(current, "mouseleave", () => {
        if (!state.disabled()) {
          state.blur();
        }
      });
    }
  });
  return (0, import_solid_js82.createComponent)(
    Button,
    (0, import_solid_js82.mergeProps)(
      (0, import_props53.omitProps)(props, ["as", "children", "disabled", "value", "ref"]),
      LISTBOX_OPTION_TAG,
      createOwnerAttribute(context.getId()),
      {
        get as() {
          return props.as || "li";
        },
        role: "option",
        tabindex: -1,
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      {
        get children() {
          return (0, import_solid_js82.createComponent)(SelectOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/listbox/ListboxOptions.ts
var import_solid_js84 = require("solid-js");
var import_props54 = require("solid-use/props");

// src/utils/create-type-ahead.ts
var import_solid_js83 = require("solid-js");
var TYPE_AHEAD_DEBOUNCE_TIMEOUT = 250;
function createTypeAhead(callback, time = TYPE_AHEAD_DEBOUNCE_TIMEOUT) {
  let characters = "";
  let timeout;
  (0, import_solid_js83.onCleanup)(() => {
    if (timeout) {
      clearTimeout(timeout);
    }
  });
  return (value) => {
    characters += value;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      callback(characters);
      characters = "";
    }, time);
  };
}

// src/components/listbox/ListboxOptions.ts
function ListboxOptions(props) {
  const context = useListboxContext("ListboxOptions");
  const selectState = useSelectState();
  const disclosureState = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const controller = createListboxOptionsFocusNavigator(context.optionsID);
  const pushCharacter = createTypeAhead((value) => {
    controller.setFirstMatch(value);
  });
  (0, import_solid_js84.onMount)(() => {
    (0, import_solid_js84.createEffect)(() => {
      const current = internalRef();
      if (current instanceof HTMLElement && disclosureState.isOpen()) {
        controller.setRef(current);
        (0, import_solid_js84.onCleanup)(() => {
          controller.clearRef();
        });
        if ((0, import_solid_js84.untrack)(() => selectState.hasSelected())) {
          controller.setFirstChecked(SELECTED_NODE);
        } else {
          controller.setFirstChecked();
        }
        use_event_listener_default(current, "keydown", (e) => {
          if (!selectState.disabled()) {
            switch (e.key) {
              case "Escape": {
                disclosureState.close();
                break;
              }
              case "ArrowLeft": {
                if (context.horizontal) {
                  e.preventDefault();
                  controller.setPrevChecked(true);
                }
                break;
              }
              case "ArrowUp": {
                if (!context.horizontal) {
                  e.preventDefault();
                  controller.setPrevChecked(true);
                }
                break;
              }
              case "ArrowRight": {
                if (context.horizontal) {
                  e.preventDefault();
                  controller.setNextChecked(true);
                }
                break;
              }
              case "ArrowDown": {
                if (!context.horizontal) {
                  e.preventDefault();
                  controller.setNextChecked(true);
                }
                break;
              }
              case "Home": {
                e.preventDefault();
                controller.setFirstChecked();
                break;
              }
              case "End": {
                e.preventDefault();
                controller.setLastChecked();
                break;
              }
              case " ":
              case "Enter": {
                e.preventDefault();
                break;
              }
              default: {
                if (e.key.length === 1) {
                  pushCharacter(e.key);
                }
                break;
              }
            }
          }
        });
        use_event_listener_default(current, "focusout", (e) => {
          if (context.buttonHovering || context.optionsHovering) {
            return;
          }
          if (!(e.relatedTarget && current.contains(e.relatedTarget))) {
            disclosureState.close();
          }
        });
        use_event_listener_default(current, "focusin", (e) => {
          if (e.target && e.target !== current) {
            controller.setCurrent(e.target);
          }
        });
        use_event_listener_default(current, "mouseenter", () => {
          context.optionsHovering = true;
        });
        use_event_listener_default(current, "mouseleave", () => {
          context.optionsHovering = false;
        });
      }
    });
  });
  return createUnmountable(
    props,
    () => disclosureState.isOpen(),
    () => (0, import_solid_js84.createComponent)(ListboxOptionsContext.Provider, {
      value: controller,
      get children() {
        return createDynamic(
          () => props.as || "ul",
          (0, import_solid_js84.mergeProps)(
            (0, import_props54.omitProps)(props, ["as", "children", "ref"]),
            LISTBOX_OPTIONS_TAG,
            {
              id: context.optionsID,
              role: "listbox",
              "aria-multiselectable": context.multiple,
              "aria-labelledby": context.buttonID,
              ref: setInternalRef,
              get "aria-orientation"() {
                return context.horizontal ? "horizontal" : "vertical";
              },
              get tabindex() {
                return selectState.disabled() ? -1 : 0;
              }
            },
            createDisabledState(() => selectState.disabled()),
            createARIADisabledState(() => selectState.disabled()),
            createExpandedState(() => disclosureState.isOpen()),
            createHasSelectedState(() => selectState.hasSelected()),
            createHasActiveState(() => selectState.hasActive()),
            {
              get children() {
                return (0, import_solid_js84.createComponent)(SelectStateProvider, {
                  state: selectState,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    })
  );
}

// src/components/menu/Menu.ts
var import_solid_js86 = require("solid-js");
var import_props55 = require("solid-use/props");

// src/components/menu/MenuContext.ts
var import_solid_js85 = require("solid-js");
var MenuContext = (0, import_solid_js85.createContext)();
function useMenuContext(componentName) {
  const context = (0, import_solid_js85.useContext)(MenuContext);
  assert(context, new Error(`<${componentName}> must be used inside a <Menu>`));
  return context;
}
function createMenuItemFocusNavigator() {
  return new FocusNavigator((0, import_solid_js85.createUniqueId)());
}

// src/components/menu/tags.ts
var MENU_TAG = createTag("menu");
var MENU_ITEM_TAG = createTag("menu-item");

// src/components/menu/Menu.ts
function Menu(props) {
  const controller = createMenuItemFocusNavigator();
  const [ref, setRef] = createForwardRef(props);
  const pushCharacter = createTypeAhead((value) => {
    controller.setFirstMatch(value);
  });
  (0, import_solid_js86.createEffect)(() => {
    const current = ref();
    if (current instanceof HTMLElement) {
      controller.setRef(current);
      (0, import_solid_js86.onCleanup)(() => {
        controller.clearRef();
      });
      use_event_listener_default(current, "keydown", (e) => {
        switch (e.key) {
          case "ArrowUp":
          case "ArrowLeft": {
            e.preventDefault();
            controller.setPrevChecked(true);
            break;
          }
          case "ArrowDown":
          case "ArrowRight": {
            e.preventDefault();
            controller.setNextChecked(true);
            break;
          }
          case "Home": {
            e.preventDefault();
            controller.setFirstChecked();
            break;
          }
          case "End": {
            e.preventDefault();
            controller.setLastChecked();
            break;
          }
          case " ":
          case "Enter": {
            e.preventDefault();
            break;
          }
          default: {
            if (e.key.length === 1) {
              pushCharacter(e.key);
            }
            break;
          }
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          controller.setCurrent(e.target);
        }
      });
    }
  });
  return (0, import_solid_js86.createComponent)(MenuContext.Provider, {
    value: controller,
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js86.mergeProps)((0, import_props55.omitProps)(props, ["as", "ref"]), MENU_TAG, {
          id: controller.getId(),
          role: "menu",
          ref: setRef
        })
      );
    }
  });
}

// src/components/menu/MenuChild.ts
var import_solid_js87 = require("solid-js");
function MenuChild(props) {
  return (0, import_solid_js87.createMemo)(() => {
    const body = props.children;
    if (typeof body === "function") {
      return body({
        disabled: () => !!props.disabled
      });
    }
    return body;
  });
}

// src/components/menu/MenuItem.ts
var import_solid_js88 = require("solid-js");
var import_props56 = require("solid-use/props");
function MenuItem(props) {
  const context = useMenuContext("MenuItem");
  return (0, import_solid_js88.createComponent)(
    Button,
    (0, import_solid_js88.mergeProps)(
      (0, import_props56.omitProps)(props, ["as", "disabled", "ref", "children"]),
      MENU_ITEM_TAG,
      createOwnerAttribute(context.getId()),
      {
        get as() {
          return props.as || "li";
        },
        role: "menuitem",
        tabindex: -1
      },
      createDisabledState(() => props.disabled),
      createARIADisabledState(() => props.disabled),
      {
        get children() {
          return (0, import_solid_js88.createComponent)(MenuChild, {
            get disabled() {
              return props.disabled;
            },
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/popover/Popover.ts
var import_solid_js90 = require("solid-js");
var import_props57 = require("solid-use/props");

// src/components/popover/PopoverContext.ts
var import_solid_js89 = require("solid-js");
var PopoverContext = (0, import_solid_js89.createContext)();
function usePopoverContext(componentName) {
  const context = (0, import_solid_js89.useContext)(PopoverContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Popover>`)
  );
  return context;
}

// src/components/popover/tags.ts
var POPOVER_TAG = createTag("popover");
var POPOVER_BUTTON_TAG = createTag("popover-button");
var POPOVER_OVERLAY_TAG = createTag("popover-overlay");
var POPOVER_PANEL_TAG = createTag("popover-panel");

// src/components/popover/Popover.ts
function isPopoverUncontrolled(props) {
  return "defaultOpen" in props;
}
function Popover(props) {
  const ownerID = (0, import_solid_js90.createUniqueId)();
  const buttonID = (0, import_solid_js90.createUniqueId)();
  const panelID = (0, import_solid_js90.createUniqueId)();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  (0, import_solid_js90.createEffect)(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  return (0, import_solid_js90.createComponent)(PopoverContext.Provider, {
    value: {
      ownerID,
      buttonID,
      panelID,
      hovering: false
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js90.mergeProps)(
          isPopoverUncontrolled(props) ? (0, import_props57.omitProps)(props, [
            "as",
            "children",
            "defaultOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]) : (0, import_props57.omitProps)(props, [
            "as",
            "children",
            "isOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]),
          POPOVER_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createExpandedState(() => state.isOpen()),
          {
            get children() {
              return (0, import_solid_js90.createComponent)(DisclosureStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/popover/PopoverButton.ts
var import_solid_js91 = require("solid-js");
var import_props58 = require("solid-use/props");
function PopoverButton(props) {
  const context = usePopoverContext("PopoverButton");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => state.disabled() || props.disabled;
  (0, import_solid_js91.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          state.toggle();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.hovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.hovering = false;
      });
    }
  });
  return (0, import_solid_js91.createComponent)(
    Button,
    (0, import_solid_js91.mergeProps)(
      (0, import_props58.omitProps)(props, ["children", "ref"]),
      POPOVER_BUTTON_TAG,
      {
        id: context.buttonID,
        ref: setInternalRef,
        get "aria-controls"() {
          return state.isOpen() && context.panelID;
        }
      },
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createExpandedState(() => state.isOpen()),
      createARIAExpandedState(() => state.isOpen()),
      {
        get children() {
          return (0, import_solid_js91.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/popover/PopoverOverlay.ts
var import_solid_js92 = require("solid-js");
var import_props59 = require("solid-use/props");
function PopoverOverlay(props) {
  usePopoverContext("PopoverOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js92.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js92.mergeProps)(
      (0, import_props59.omitProps)(props, ["as", "children", "ref"]),
      POPOVER_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return (0, import_solid_js92.createComponent)(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/popover/PopoverPanel.ts
var import_solid_js93 = require("solid-js");
var import_props60 = require("solid-use/props");
function PopoverPanel(props) {
  const context = usePopoverContext("PopoverPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  (0, import_solid_js93.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement && state.isOpen()) {
      focusFirst(getFocusableElements(current), false);
      use_event_listener_default(current, "keydown", (e) => {
        if (!state.disabled()) {
          switch (e.key) {
            case "Tab": {
              e.preventDefault();
              lockFocus(current, e.shiftKey, false);
              break;
            }
            case "Escape": {
              state.close();
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "focusout", (e) => {
        if (context.hovering) {
          return;
        }
        if (!(e.relatedTarget && current.contains(e.relatedTarget))) {
          state.close();
        }
      });
    }
  });
  return createUnmountable(
    props,
    () => state.isOpen(),
    () => createDynamic(
      () => props.as || "div",
      (0, import_solid_js93.mergeProps)(
        (0, import_props60.omitProps)(props, ["as", "unmount", "children", "ref"]),
        POPOVER_PANEL_TAG,
        {
          id: context.panelID,
          ref: setInternalRef,
          get children() {
            return (0, import_solid_js93.createComponent)(DisclosureStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        },
        createDisabledState(() => state.disabled()),
        createExpandedState(() => state.isOpen())
      )
    )
  );
}

// src/components/radio-group/RadioGroup.ts
var import_solid_js96 = require("solid-js");
var import_props61 = require("solid-use/props");

// src/components/radio-group/RadioGroupContext.ts
var import_solid_js94 = require("solid-js");
var RadioGroupContext = (0, import_solid_js94.createContext)();
function useRadioGroupContext(componentName) {
  const context = (0, import_solid_js94.useContext)(RadioGroupContext);
  assert(
    context,
    new Error(
      `<${componentName}> must be used inside a <RadioGroup> or <RadioGroupOption>`
    )
  );
  return context;
}

// src/components/radio-group/RadioGroupRootContext.ts
var import_solid_js95 = require("solid-js");
var RadioGroupRootContext = (0, import_solid_js95.createContext)();
function useRadioGroupRootContext(componentName) {
  const context = (0, import_solid_js95.useContext)(RadioGroupRootContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <RadioGroup>`)
  );
  return context;
}
function createRadioGroupOptionFocusNavigator() {
  return new FocusNavigator((0, import_solid_js95.createUniqueId)());
}

// src/components/radio-group/tags.ts
var RADIO_GROUP_TAG = createTag("radio-group");
var RADIO_GROUP_DESCRIPTION_TAG = createTag("radio-group-description");
var RADIO_GROUP_LABEL_TAG = createTag("radio-group-label");
var RADIO_GROUP_OPTION_TAG = createTag("radio-group-option");

// src/components/radio-group/RadioGroup.ts
function isRadioGroupUncontrolled(props) {
  return "defaultValue" in props;
}
function RadioGroup(props) {
  const controller = createRadioGroupOptionFocusNavigator();
  const descriptionID = (0, import_solid_js96.createUniqueId)();
  const labelID = (0, import_solid_js96.createUniqueId)();
  const state = createSingleSelectState(props);
  const [ref, setRef] = createForwardRef(props);
  (0, import_solid_js96.createEffect)(() => {
    const current = ref();
    if (current instanceof HTMLElement) {
      controller.setRef(current);
      (0, import_solid_js96.onCleanup)(() => {
        controller.clearRef();
      });
      use_event_listener_default(current, "keydown", (e) => {
        if (!state.disabled()) {
          switch (e.key) {
            case "ArrowLeft":
            case "ArrowUp": {
              e.preventDefault();
              controller.setPrevChecked(true);
              break;
            }
            case "ArrowRight":
            case "ArrowDown": {
              e.preventDefault();
              controller.setNextChecked(true);
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          controller.setCurrent(e.target);
        }
      });
    }
  });
  return (0, import_solid_js96.createComponent)(RadioGroupRootContext.Provider, {
    value: controller,
    get children() {
      return (0, import_solid_js96.createComponent)(RadioGroupContext.Provider, {
        value: {
          descriptionID,
          labelID
        },
        get children() {
          return createDynamic(
            () => props.as || "div",
            (0, import_solid_js96.mergeProps)(
              isRadioGroupUncontrolled(props) ? (0, import_props61.omitProps)(props, [
                "as",
                "by",
                "children",
                "defaultValue",
                "disabled",
                "multiple",
                "onChange",
                "ref",
                "toggleable"
              ]) : (0, import_props61.omitProps)(props, [
                "as",
                "by",
                "children",
                "value",
                "disabled",
                "multiple",
                "onChange",
                "ref",
                "toggleable"
              ]),
              RADIO_GROUP_TAG,
              {
                role: "radiogroup",
                "aria-labelledby": labelID,
                "aria-describedby": descriptionID,
                ref: setRef
              },
              createDisabledState(() => state.disabled()),
              createARIADisabledState(() => state.disabled()),
              createHasActiveState(() => state.hasActive()),
              createHasSelectedState(() => state.hasSelected()),
              {
                get children() {
                  return (0, import_solid_js96.createComponent)(SelectStateProvider, {
                    state,
                    get children() {
                      return props.children;
                    }
                  });
                }
              }
            )
          );
        }
      });
    }
  });
}

// src/components/radio-group/RadioGroupDescription.ts
var import_solid_js97 = require("solid-js");
var import_props62 = require("solid-use/props");
function RadioGroupDescription(props) {
  const context = useRadioGroupContext("RadioGroupDescription");
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js97.mergeProps)((0, import_props62.omitProps)(props, ["as"]), RADIO_GROUP_DESCRIPTION_TAG, {
      id: context.descriptionID
    })
  );
}

// src/components/radio-group/RadioGroupLabel.ts
var import_solid_js98 = require("solid-js");
var import_props63 = require("solid-use/props");
function RadioGroupLabel(props) {
  const context = useRadioGroupContext("RadioGroupLabel");
  return createDynamic(
    () => props.as || "label",
    (0, import_solid_js98.mergeProps)((0, import_props63.omitProps)(props, ["as"]), RADIO_GROUP_LABEL_TAG, {
      id: context.labelID
    })
  );
}

// src/components/radio-group/RadioGroupOption.ts
var import_solid_js99 = require("solid-js");
var import_props64 = require("solid-use/props");
function RadioGroupOption(props) {
  const context = useRadioGroupRootContext("RadioGroupOption");
  const descriptionID = (0, import_solid_js99.createUniqueId)();
  const labelID = (0, import_solid_js99.createUniqueId)();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const state = createSelectOptionState(props);
  (0, import_solid_js99.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.select();
      });
      use_event_listener_default(current, "focus", () => {
        state.focus();
        state.select();
      });
      use_event_listener_default(current, "blur", () => {
        state.blur();
      });
    }
  });
  return (0, import_solid_js99.createComponent)(RadioGroupContext.Provider, {
    value: { descriptionID, labelID },
    get children() {
      return (0, import_solid_js99.createComponent)(
        Button,
        (0, import_solid_js99.mergeProps)(
          (0, import_props64.omitProps)(props, ["as", "children", "value", "disabled", "ref"]),
          RADIO_GROUP_OPTION_TAG,
          createOwnerAttribute(context.getId()),
          {
            get as() {
              return props.as || "div";
            },
            role: "radio",
            "aria-labelledby": labelID,
            "aria-describedby": descriptionID,
            ref: setInternalRef,
            get tabindex() {
              const selected = state.isSelected();
              return state.disabled() || !selected ? -1 : 0;
            }
          },
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createCheckedState(() => state.isSelected()),
          createARIACheckedState(() => state.isSelected()),
          createActiveState(() => state.isActive()),
          {
            get children() {
              return (0, import_solid_js99.createComponent)(SelectOptionStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/select/Select.ts
var import_solid_js101 = require("solid-js");
var import_props65 = require("solid-use/props");

// src/components/select/SelectContext.ts
var import_solid_js100 = require("solid-js");
var SelectContext = (0, import_solid_js100.createContext)();
function useSelectContext(componentName) {
  const context = (0, import_solid_js100.useContext)(SelectContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Select>`)
  );
  return context;
}
function createSelectOptionFocusNavigator() {
  return new FocusNavigator((0, import_solid_js100.createUniqueId)());
}

// src/components/select/tags.ts
var SELECT_TAG = createTag("select");
var SELECT_OPTION_TAG = createTag("select-option");

// src/components/select/Select.ts
function isSelectMultiple(props) {
  return !!props.multiple;
}
function isSelectUncontrolled(props) {
  return "defaultValue" in props;
}
function Select(props) {
  return (0, import_solid_js101.createMemo)(() => {
    const controller = createSelectOptionFocusNavigator();
    const [ref, setRef] = createForwardRef(props);
    const state = isSelectMultiple(props) ? createMultipleSelectState(props) : createSingleSelectState(props);
    const pushCharacter = createTypeAhead((value) => {
      controller.setFirstMatch(value);
    });
    (0, import_solid_js101.createEffect)(() => {
      const current = ref();
      if (current instanceof HTMLElement) {
        controller.setRef(current);
        (0, import_solid_js101.onCleanup)(() => {
          controller.clearRef();
        });
        use_event_listener_default(current, "keydown", (e) => {
          if (!state.disabled()) {
            switch (e.key) {
              case "ArrowUp": {
                if (!props.horizontal) {
                  e.preventDefault();
                  controller.setPrevChecked(true);
                }
                break;
              }
              case "ArrowLeft": {
                if (props.horizontal) {
                  e.preventDefault();
                  controller.setPrevChecked(true);
                }
                break;
              }
              case "ArrowDown": {
                if (!props.horizontal) {
                  e.preventDefault();
                  controller.setNextChecked(true);
                }
                break;
              }
              case "ArrowRight": {
                if (props.horizontal) {
                  e.preventDefault();
                  controller.setNextChecked(true);
                }
                break;
              }
              case "Home": {
                e.preventDefault();
                controller.setFirstChecked();
                break;
              }
              case "End": {
                e.preventDefault();
                controller.setLastChecked();
                break;
              }
              case " ":
              case "Enter": {
                e.preventDefault();
                break;
              }
              default: {
                if (e.key.length === 1) {
                  pushCharacter(e.key);
                }
                break;
              }
            }
          }
        });
        use_event_listener_default(current, "focus", () => {
          if (state.hasSelected()) {
            controller.setFirstChecked(SELECTED_NODE);
          } else {
            controller.setFirstChecked();
          }
        });
        use_event_listener_default(current, "focusin", (e) => {
          if (e.target && e.target !== current) {
            controller.setCurrent(e.target);
          }
        });
      }
    });
    return (0, import_solid_js101.createComponent)(SelectContext.Provider, {
      value: {
        controller,
        get horizontal() {
          return !!props.horizontal;
        }
      },
      get children() {
        return createDynamic(
          () => props.as || "ul",
          (0, import_solid_js101.mergeProps)(
            isSelectUncontrolled(props) ? (0, import_props65.omitProps)(props, [
              "as",
              "by",
              "children",
              "defaultValue",
              "disabled",
              "horizontal",
              "multiple",
              "onChange",
              "ref",
              "toggleable"
            ]) : (0, import_props65.omitProps)(props, [
              "as",
              "by",
              "children",
              "value",
              "disabled",
              "horizontal",
              "multiple",
              "onChange",
              "ref",
              "toggleable"
            ]),
            SELECT_TAG,
            {
              id: controller.getId(),
              role: "listbox",
              get "aria-multiselectable"() {
                return props.multiple;
              },
              ref: setRef,
              get "aria-orientation"() {
                return props.horizontal ? "horizontal" : "vertical";
              },
              get tabindex() {
                return state.hasActive() ? -1 : 0;
              }
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createHasSelectedState(() => state.hasSelected()),
            createHasActiveState(() => state.hasActive()),
            {
              get children() {
                return (0, import_solid_js101.createComponent)(SelectStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    });
  });
}

// src/components/select/SelectOption.ts
var import_solid_js102 = require("solid-js");
var import_props66 = require("solid-use/props");
function SelectOption(props) {
  const context = useSelectContext("SelectOption");
  const [internalRef, setInternalRef] = createForwardRef(props);
  const state = createSelectOptionState(props);
  (0, import_solid_js102.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.select();
      });
      use_event_listener_default(current, "focus", () => {
        state.focus();
      });
      use_event_listener_default(current, "blur", () => {
        state.blur();
      });
      use_event_listener_default(current, "mouseenter", () => {
        if (!state.disabled()) {
          current.focus();
        }
      });
      use_event_listener_default(current, "mouseleave", () => {
        if (!state.disabled()) {
          current.blur();
        }
      });
    }
  });
  return (0, import_solid_js102.createComponent)(
    Button,
    (0, import_solid_js102.mergeProps)(
      (0, import_props66.omitProps)(props, ["as", "children", "value", "ref"]),
      SELECT_OPTION_TAG,
      createOwnerAttribute(context.controller.getId()),
      {
        get as() {
          return props.as || "li";
        },
        role: "option",
        get tabindex() {
          return state.isActive() ? 0 : -1;
        },
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      {
        get children() {
          return (0, import_solid_js102.createComponent)(SelectOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/tabs/Tab.ts
var import_solid_js105 = require("solid-js");
var import_props67 = require("solid-use/props");

// src/components/tabs/TabGroupContext.ts
var import_solid_js103 = require("solid-js");
var TabGroupContext = (0, import_solid_js103.createContext)();
function useTabGroupContext(componentName) {
  const context = (0, import_solid_js103.useContext)(TabGroupContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <TabGroup>`)
  );
  return context;
}

// src/components/tabs/TabListContext.ts
var import_solid_js104 = require("solid-js");
var TabListContext = (0, import_solid_js104.createContext)();
function useTabListContext(componentName) {
  const context = (0, import_solid_js104.useContext)(TabListContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <TabList>`)
  );
  return context;
}
function createTabFocusNavigator() {
  return new FocusNavigator((0, import_solid_js104.createUniqueId)());
}

// src/components/tabs/tags.ts
var TAB_GROUP_TAG = createTag("tab-group");
var TAB_LIST_TAG = createTag("tab-list");
var TAB_TAG = createTag("tab");
var TAB_PANEL_TAG = createTag("tab-panel");

// src/components/tabs/Tab.ts
function Tab(props) {
  const rootContext = useTabGroupContext("Tab");
  const listContext = useTabListContext("Tab");
  const [internalRef, setInternalRef] = createForwardRef(props);
  const state = createSelectOptionState(props);
  (0, import_solid_js105.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.select();
      });
      use_event_listener_default(current, "focus", () => {
        state.focus();
        state.select();
      });
      use_event_listener_default(current, "blur", () => {
        state.blur();
        state.select();
      });
    }
  });
  return (0, import_solid_js105.createComponent)(
    Button,
    (0, import_solid_js105.mergeProps)(
      (0, import_props67.omitProps)(props, ["as", "children", "value", "disabled", "ref"]),
      TAB_TAG,
      createOwnerAttribute(listContext.getId()),
      {
        get as() {
          return props.as || "div";
        },
        role: "tab",
        ref: setInternalRef,
        get id() {
          return rootContext.getId("tab", props.value);
        },
        get "aria-controls"() {
          return rootContext.getId("tab-panel", props.value);
        },
        get tabindex() {
          const selected = state.isSelected();
          return state.disabled() || !selected ? -1 : 0;
        },
        get children() {
          return (0, import_solid_js105.createComponent)(SelectOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive())
    )
  );
}

// src/components/tabs/TabGroup.ts
var import_solid_js106 = require("solid-js");
var import_props68 = require("solid-use/props");
function isTabGroupUncontrolled(props) {
  return "defaultValue" in props;
}
function TabGroup(props) {
  return (0, import_solid_js106.createMemo)(() => {
    const ownerID = (0, import_solid_js106.createUniqueId)();
    const state = createSingleSelectState(props);
    const ids = /* @__PURE__ */ new Map();
    return (0, import_solid_js106.createComponent)(TabGroupContext.Provider, {
      value: {
        get horizontal() {
          return props.horizontal;
        },
        getId(kind, value) {
          let currentID = ids.get(value);
          if (!currentID) {
            currentID = ids.size;
            ids.set(value, currentID);
          }
          return `${ownerID}__${kind}-${currentID}`;
        }
      },
      get children() {
        return createDynamic(
          () => props.as || "div",
          (0, import_solid_js106.mergeProps)(
            isTabGroupUncontrolled(props) ? (0, import_props68.omitProps)(props, [
              "as",
              "children",
              "defaultValue",
              "disabled",
              "onChange",
              "by",
              "ref",
              "toggleable",
              "horizontal"
            ]) : (0, import_props68.omitProps)(props, [
              "as",
              "children",
              "value",
              "disabled",
              "onChange",
              "by",
              "ref",
              "toggleable",
              "horizontal"
            ]),
            TAB_GROUP_TAG,
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createHasSelectedState(() => state.hasSelected()),
            createHasActiveState(() => state.hasActive()),
            {
              get children() {
                return (0, import_solid_js106.createComponent)(SelectStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    });
  });
}

// src/components/tabs/TabList.ts
var import_solid_js107 = require("solid-js");
var import_props69 = require("solid-use/props");
function TabList(props) {
  const rootContext = useTabGroupContext("TabList");
  const controller = createTabFocusNavigator();
  const state = useSelectState();
  const [ref, setRef] = createForwardRef(props);
  (0, import_solid_js107.createEffect)(() => {
    const current = ref();
    if (current instanceof HTMLElement) {
      controller.setRef(current);
      (0, import_solid_js107.onCleanup)(() => {
        controller.clearRef();
      });
      use_event_listener_default(current, "keydown", (e) => {
        if (!state.disabled()) {
          switch (e.key) {
            case "ArrowUp": {
              if (!rootContext.horizontal) {
                e.preventDefault();
                controller.setPrevChecked(true);
              }
              break;
            }
            case "ArrowLeft": {
              if (rootContext.horizontal) {
                e.preventDefault();
                controller.setPrevChecked(true);
              }
              break;
            }
            case "ArrowDown": {
              if (!rootContext.horizontal) {
                e.preventDefault();
                controller.setNextChecked(true);
              }
              break;
            }
            case "ArrowRight": {
              if (rootContext.horizontal) {
                e.preventDefault();
                controller.setNextChecked(true);
              }
              break;
            }
            case "Home": {
              e.preventDefault();
              controller.setFirstChecked();
              break;
            }
            case "End": {
              e.preventDefault();
              controller.setLastChecked();
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          controller.setCurrent(e.target);
        }
      });
    }
  });
  return (0, import_solid_js107.createComponent)(TabListContext.Provider, {
    value: controller,
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js107.mergeProps)(
          (0, import_props69.omitProps)(props, ["as", "ref", "children"]),
          TAB_LIST_TAG,
          {
            role: "tablist",
            get "aria-orientation"() {
              return rootContext.horizontal ? "horizontal" : "vertical";
            },
            ref: setRef,
            get children() {
              return (0, import_solid_js107.createComponent)(SelectStateChild, {
                get children() {
                  return props.children;
                }
              });
            }
          },
          createHasSelectedState(() => state.hasSelected()),
          createHasActiveState(() => state.hasActive())
        )
      );
    }
  });
}

// src/components/tabs/TabPanel.ts
var import_solid_js108 = require("solid-js");
var import_props70 = require("solid-use/props");
function TabPanel(props) {
  const rootContext = useTabGroupContext("TabPanel");
  const state = createSelectOptionState(props);
  return createUnmountable(
    props,
    () => state.isSelected(),
    () => createDynamic(
      () => props.as || "div",
      (0, import_solid_js108.mergeProps)(
        (0, import_props70.omitProps)(props, ["as", "disabled", "unmount", "value"]),
        TAB_PANEL_TAG,
        {
          role: "tabpanel",
          get tabindex() {
            return state.isSelected() ? 0 : -1;
          },
          get id() {
            return rootContext.getId("tab-panel", props.value);
          },
          get "aria-labelledby"() {
            return rootContext.getId("tab", props.value);
          },
          get children() {
            return (0, import_solid_js108.createComponent)(SelectOptionStateProvider, {
              state,
              get children() {
                return props.children;
              }
            });
          }
        },
        createSelectedState(() => state.isSelected()),
        createActiveState(() => state.isActive())
      )
    )
  );
}

// src/components/toast/index.ts
var import_solid_js109 = require("solid-js");
var import_props71 = require("solid-use/props");
var TOAST_TAG = createTag("toast");
var TOASTER_TAG = createTag("toaster");
var ToastContext = (0, import_solid_js109.createContext)();
function useToastContext(componentName) {
  const context = (0, import_solid_js109.useContext)(ToastContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Toaster>`)
  );
  return context;
}
function Toast(props) {
  useToastContext("Toast");
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js109.mergeProps)((0, import_props71.omitProps)(props, ["as"]), TOAST_TAG, {
      role: "status",
      "aria-live": "polite"
    })
  );
}
function Toaster(props) {
  const ownerID = (0, import_solid_js109.createUniqueId)();
  return (0, import_solid_js109.createComponent)(ToastContext.Provider, {
    value: {
      ownerID
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        (0, import_solid_js109.mergeProps)((0, import_props71.omitProps)(props, ["as"]), TOASTER_TAG)
      );
    }
  });
}
var _ToasterStore = class _ToasterStore {
  constructor() {
    this.queue = [];
    this.listeners = /* @__PURE__ */ new Set();
    this.toastID = 0;
    this.id = _ToasterStore.toasterID;
    _ToasterStore.toasterID += 1;
  }
  subscribe(callback) {
    this.listeners.add(callback);
    return () => {
      this.listeners.delete(callback);
    };
  }
  notify() {
    const clone = [...this.queue];
    for (const listener of this.listeners.keys()) {
      listener(clone);
    }
  }
  create(data) {
    const id = `toast-${this.id}-[${this.toastID}`;
    this.toastID += 1;
    this.queue.push({
      id,
      data
    });
    this.notify();
    return id;
  }
  remove(id) {
    this.queue = this.queue.filter((item) => item.id !== id);
    this.notify();
  }
  clear() {
    this.queue = [];
    this.notify();
  }
  getQueue() {
    return this.queue;
  }
};
_ToasterStore.toasterID = 0;
var ToasterStore = _ToasterStore;
function useToaster(toaster) {
  const [signal, setSignal] = (0, import_solid_js109.createSignal)(toaster.getQueue());
  (0, import_solid_js109.createEffect)(() => {
    (0, import_solid_js109.onCleanup)(toaster.subscribe(setSignal));
  });
  return signal;
}

// src/components/toggle/index.ts
var import_solid_js111 = require("solid-js");
var import_props72 = require("solid-use/props");

// src/states/create-toggle-state.ts
var import_solid_js110 = require("solid-js");
function createToggleState(options) {
  let signal;
  let setSignal;
  if ("defaultPressed" in options) {
    const [isOpen, setIsOpen] = (0, import_solid_js110.createSignal)(options.defaultPressed);
    signal = isOpen;
    setSignal = (value) => {
      setIsOpen(value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    signal = (0, import_solid_js110.createMemo)(() => options.pressed);
    setSignal = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = (0, import_solid_js110.createMemo)(() => !!options.disabled);
  return {
    pressed() {
      return signal();
    },
    setState(value) {
      if (!(0, import_solid_js110.untrack)(isDisabled)) {
        setSignal(value);
      }
    },
    disabled: isDisabled,
    check() {
      if (!(0, import_solid_js110.untrack)(isDisabled)) {
        setSignal(true);
      }
    },
    uncheck() {
      if (!(0, import_solid_js110.untrack)(isDisabled)) {
        setSignal(false);
      }
    },
    toggle() {
      if (!(0, import_solid_js110.untrack)(isDisabled)) {
        setSignal(!(0, import_solid_js110.untrack)(signal));
      }
    }
  };
}
var ToggleStateContext = (0, import_solid_js110.createContext)();
function ToggleStateProvider(props) {
  return (0, import_solid_js110.createComponent)(ToggleStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useToggleState() {
  const ctx = (0, import_solid_js110.useContext)(ToggleStateContext);
  assert(ctx, new Error("Missing <ToggleStateProvider>"));
  return ctx;
}
function ToggleStateChild(props) {
  const state = useToggleState();
  return (0, import_solid_js110.createMemo)(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return (0, import_solid_js110.createMemo)(() => current(state));
    }
    return current;
  });
}

// src/components/toggle/index.ts
var TOGGLE_TAG = createTag("toggle");
function isToggleUncontrolled(props) {
  return "defaultPressed" in props;
}
function Toggle(props) {
  const [ref, setRef] = createForwardRef(props);
  const state = createToggleState(props);
  (0, import_solid_js111.createEffect)(() => {
    const current = ref();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.toggle();
      });
    }
  });
  return (0, import_solid_js111.createComponent)(
    Button,
    (0, import_solid_js111.mergeProps)(
      isToggleUncontrolled(props) ? (0, import_props72.omitProps)(props, [
        "onChange",
        "defaultPressed",
        "ref",
        "disabled",
        "children"
      ]) : (0, import_props72.omitProps)(props, [
        "onChange",
        "pressed",
        "ref",
        "disabled",
        "children"
      ]),
      TOGGLE_TAG,
      {
        ref: setRef,
        get children() {
          return (0, import_solid_js111.createComponent)(ToggleStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      },
      createPressedState(() => state.pressed()),
      createARIAPressedState(() => state.pressed()),
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled())
    )
  );
}

// src/components/toolbar/index.ts
var import_solid_js112 = require("solid-js");
var import_props73 = require("solid-use/props");
var TOOLBAR_TAG = createTag("toolbar");
function Toolbar(props) {
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isHorizontal = () => props.horizontal == null ? true : props.horizontal;
  let focusedElement;
  function getNextFocusable2() {
    const ref = internalRef();
    if (ref instanceof HTMLElement && document.activeElement && ref.contains(document.activeElement)) {
      focusNext(
        getFocusableElements(ref),
        document.activeElement,
        false,
        false
      );
    }
  }
  function getPrevFocusable() {
    const ref = internalRef();
    if (ref instanceof HTMLElement && document.activeElement && ref.contains(document.activeElement)) {
      focusPrev(
        getFocusableElements(ref),
        document.activeElement,
        false,
        false
      );
    }
  }
  (0, import_solid_js112.createEffect)(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "keydown", (e) => {
        switch (e.key) {
          case "ArrowLeft": {
            if (isHorizontal()) {
              e.preventDefault();
              getPrevFocusable();
            }
            break;
          }
          case "ArrowUp": {
            if (!isHorizontal()) {
              e.preventDefault();
              getPrevFocusable();
            }
            break;
          }
          case "ArrowRight": {
            if (isHorizontal()) {
              e.preventDefault();
              getNextFocusable2();
            }
            break;
          }
          case "ArrowDown": {
            if (!isHorizontal()) {
              e.preventDefault();
              getNextFocusable2();
            }
            break;
          }
          case "Home": {
            if (focusFirst(getFocusableElements(current), false)) {
              e.preventDefault();
            }
            break;
          }
          case "End": {
            if (focusLast(getFocusableElements(current), false)) {
              e.preventDefault();
            }
            break;
          }
        }
      });
      use_event_listener_default(current, "focus", () => {
        if (focusedElement) {
          focusedElement.focus();
        } else {
          focusFirst(getFocusableElements(current), false);
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          focusedElement = e.target;
        }
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    (0, import_solid_js112.mergeProps)((0, import_props73.omitProps)(props, ["as", "horizontal", "ref"]), TOOLBAR_TAG, {
      role: "toolbar",
      tabindex: 0,
      ref: setInternalRef,
      get "aria-orientation"() {
        return isHorizontal() ? "horizontal" : "vertical";
      }
    })
  );
}

// src/components/transition/index.ts
var import_solid_js113 = require("solid-js");
var import_props74 = require("solid-use/props");
var TransitionRootContext = (0, import_solid_js113.createContext)();
var TransitionCounterContext = (0, import_solid_js113.createContext)();
function useTransitionRootContext(componentName) {
  const context = (0, import_solid_js113.useContext)(TransitionRootContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Transition>`)
  );
  return context;
}
function createTransitionCounter() {
  const [size, setSize] = (0, import_solid_js113.createSignal)(0);
  return {
    // Reactive set
    register() {
      setSize((c) => c + 1);
    },
    unregister() {
      setSize((c) => c - 1);
    },
    done() {
      return size() === 0;
    }
  };
}
function getClassList(classes) {
  return classes ? classes.split(" ") : [];
}
function addClassList(ref, classes) {
  const filtered = classes.filter((value) => value);
  if (filtered.length) {
    ref.classList.add(...filtered);
  }
}
function removeClassList(ref, classes) {
  const filtered = classes.filter((value) => value);
  if (filtered.length) {
    ref.classList.remove(...filtered);
  }
}
function TransitionChild(props) {
  const values = useTransitionRootContext("TransitionChild");
  const transitionParent = (0, import_solid_js113.useContext)(TransitionCounterContext);
  const transitionChildren = createTransitionCounter();
  const [state, setState] = (0, import_solid_js113.createSignal)();
  const [visible, setVisible] = (0, import_solid_js113.createSignal)(values.show);
  const [ref, setRef] = createForwardRef(props);
  let initial = true;
  function transition(element, shouldEnter) {
    if (shouldEnter) {
      if (initial) {
        const enter = getClassList(props.enter);
        const enterFrom = getClassList(props.enterFrom);
        const enterTo = getClassList(props.enterTo);
        const entered = getClassList(props.entered);
        const endTransition = () => {
          removeClassList(element, enter);
          removeClassList(element, enterTo);
          setState("entered");
          addClassList(element, entered);
          if (props.afterEnter) {
            props.afterEnter();
          }
        };
        if (props.beforeEnter) {
          props.beforeEnter();
        }
        setState("enter-from");
        addClassList(element, enter);
        addClassList(element, enterFrom);
        requestAnimationFrame(() => {
          removeClassList(element, enterFrom);
          setState("enter-to");
          addClassList(element, enterTo);
          element.addEventListener("transitionend", endTransition, {
            once: true
          });
          element.addEventListener("animationend", endTransition, {
            once: true
          });
        });
      }
    } else {
      const leave = getClassList(props.leave);
      const leaveFrom = getClassList(props.leaveFrom);
      const leaveTo = getClassList(props.leaveTo);
      const entered = getClassList(props.entered);
      if (props.beforeLeave) {
        props.beforeLeave();
      }
      if (transitionParent) {
        transitionParent.register();
      }
      removeClassList(element, entered);
      setState("leave-from");
      addClassList(element, leave);
      addClassList(element, leaveFrom);
      requestAnimationFrame(() => {
        removeClassList(element, leaveFrom);
        setState("leave-to");
        addClassList(element, leaveTo);
      });
      const endTransition = () => {
        removeClassList(element, leave);
        removeClassList(element, leaveTo);
        setVisible(false);
        if (transitionParent) {
          transitionParent.unregister();
        }
        if (props.afterLeave) {
          props.afterLeave();
        }
      };
      element.addEventListener("transitionend", endTransition, { once: true });
      element.addEventListener("animationend", endTransition, { once: true });
    }
  }
  (0, import_solid_js113.createEffect)(() => {
    const shouldShow = values.show;
    if (shouldShow) {
      setVisible(true);
    }
    const internalRef = ref();
    if (internalRef instanceof HTMLElement) {
      if (shouldShow) {
        transition(internalRef, true);
      } else if (transitionChildren.done()) {
        transition(internalRef, false);
      }
    } else {
      initial = true;
    }
  });
  return (0, import_solid_js113.createComponent)(TransitionCounterContext.Provider, {
    value: transitionChildren,
    get children() {
      return createUnmountable(
        props,
        visible,
        () => createDynamic(
          () => props.as || "div",
          (0, import_solid_js113.mergeProps)(
            (0, import_props74.omitProps)(props, [
              "as",
              "enter",
              "enterFrom",
              "enterTo",
              "leave",
              "leaveFrom",
              "leaveTo",
              "unmount",
              "afterEnter",
              "afterLeave",
              "appear",
              "beforeEnter",
              "beforeLeave",
              "entered",
              "ref"
            ]),
            {
              ref: setRef,
              get "tc-transition"() {
                return state();
              }
            }
          )
        )
      );
    }
  });
}
function Transition(props) {
  return (0, import_solid_js113.createComponent)(TransitionRootContext.Provider, {
    value: props,
    get children() {
      return (0, import_solid_js113.createComponent)(
        TransitionChild,
        (0, import_props74.omitProps)(props, ["show"])
      );
    }
  });
}

// src/states/create-input-state.ts
var import_solid_js114 = require("solid-js");
function createInputState(options) {
  let signal;
  let setSignal;
  if ("defaultValue" in options) {
    const [input, setInput] = (0, import_solid_js114.createSignal)(
      options.defaultValue
    );
    signal = input;
    setSignal = (value) => {
      setInput(value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    signal = () => options.value;
    setSignal = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  return {
    value() {
      return signal();
    },
    setState(value) {
      if (!options.disabled) {
        setSignal(value);
      }
    },
    disabled() {
      return !!options.disabled;
    }
  };
}
var InputStateContext = (0, import_solid_js114.createContext)();
function useInputState() {
  const ctx = (0, import_solid_js114.useContext)(InputStateContext);
  assert(ctx, new Error("Missing <InputStateProvider>"));
  return ctx;
}
function InputStateChild(props) {
  const state = useInputState();
  return (0, import_solid_js114.createMemo)(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return (0, import_solid_js114.createMemo)(() => current(state));
    }
    return current;
  });
}

// src/utils/Fragment.ts
var import_solid_js115 = require("solid-js");
function Fragment(props) {
  return (0, import_solid_js115.createMemo)(() => props.children);
}
//# sourceMappingURL=index.cjs.map
