// src/components/accordion/Accordion.ts
import {
  createComponent as createComponent3,
  createEffect as createEffect2,
  createMemo as createMemo2,
  mergeProps as mergeProps2,
  onCleanup as onCleanup3
} from "solid-js";
import { omitProps } from "solid-use/props";

// src/states/create-select-state.ts
import {
  createComponent,
  createContext,
  createMemo,
  createSignal,
  untrack,
  useContext
} from "solid-js";

// src/utils/assert.ts
function assert(cond, error) {
  if (!cond) {
    throw error;
  }
}

// src/utils/is-equal.ts
function isEqual(a, b) {
  return a === b || a !== a && b !== b;
}

// src/states/create-select-state.ts
function createSingleSelectState(options) {
  const [active, setActive] = createSignal();
  let selectedValue;
  let setSelectedValue;
  const equals = options.by || isEqual;
  if ("defaultValue" in options) {
    const [selected, setSelected] = createSignal(
      options.defaultValue
    );
    selectedValue = selected;
    setSelectedValue = (value) => {
      setSelected(() => value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    selectedValue = createMemo(() => options.value);
    setSelectedValue = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = createMemo(() => !!options.disabled);
  return {
    isSelected(value) {
      return isEqual(value, selectedValue());
    },
    select(value) {
      if (!untrack(isDisabled)) {
        if (options.toggleable && equals(untrack(selectedValue), value)) {
          setSelectedValue(void 0);
        } else {
          setSelectedValue(value);
        }
      }
    },
    hasSelected() {
      return selectedValue() != null;
    },
    disabled: isDisabled,
    hasActive() {
      return !!active();
    },
    isActive(value) {
      const ref = active();
      return ref ? equals(value, ref.value) : false;
    },
    focus(value) {
      if (!untrack(isDisabled)) {
        setActive({
          value
        });
      }
    },
    blur() {
      if (!untrack(isDisabled)) {
        setActive(void 0);
      }
    }
  };
}
function createMultipleSelectState(options) {
  const [active, setActive] = createSignal();
  let selectedValues;
  let setSelectedValues;
  const equals = options.by || isEqual;
  if ("defaultValue" in options) {
    const [selected, setSelected] = createSignal(options.defaultValue);
    selectedValues = selected;
    setSelectedValues = (value) => {
      setSelected(() => value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    selectedValues = createMemo(() => options.value);
    setSelectedValues = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = createMemo(() => !!options.disabled);
  return {
    isSelected(value) {
      const values = selectedValues();
      for (let i = 0, len = values.length; i < len; i += 1) {
        if (equals(value, values[i])) {
          return true;
        }
      }
      return false;
    },
    select(value) {
      if (!untrack(isDisabled)) {
        const newValues = [];
        const currentValues = untrack(selectedValues);
        let hasValue = false;
        for (let i = 0, len = currentValues.length; i < len; i += 1) {
          const item = currentValues[i];
          const isSame = equals(item, value);
          if (isSame) {
            hasValue = true;
          }
          if (!(options.toggleable && isSame)) {
            newValues.push(item);
          }
        }
        if (!hasValue) {
          newValues.push(value);
        }
        setSelectedValues(newValues);
      }
    },
    hasSelected: createMemo(() => selectedValues().length > 0),
    disabled: isDisabled,
    hasActive: createMemo(() => !!active()),
    isActive(value) {
      const ref = active();
      if (ref) {
        return equals(value, ref.value);
      }
      return false;
    },
    focus(value) {
      if (!untrack(isDisabled)) {
        setActive({
          value
        });
      }
    },
    blur() {
      if (!untrack(isDisabled)) {
        setActive(void 0);
      }
    }
  };
}
var SelectStateContext = createContext();
function SelectStateProvider(props) {
  return createComponent(SelectStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useSelectState() {
  const ctx = useContext(SelectStateContext);
  assert(ctx, new Error("Missing <SelectStateProvider>"));
  return ctx;
}
function SelectStateChild(props) {
  const state = useSelectState();
  return createMemo(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return createMemo(() => current(state));
    }
    return current;
  });
}

// src/utils/create-dynamic.ts
import { createComponent as createComponent2, mergeProps } from "solid-js";
import { Dynamic } from "solid-js/web";
function createDynamic(source, props) {
  return createComponent2(
    Dynamic,
    mergeProps(
      {
        get component() {
          return source();
        }
      },
      props
    )
  );
}

// src/utils/dynamic-prop.ts
import { createEffect, createSignal as createSignal2 } from "solid-js";
function isRefFunction(callback) {
  return typeof callback === "function";
}
function createForwardRef(props) {
  const [ref, setRef] = createSignal2();
  createEffect(() => {
    const current = ref();
    if (current && "ref" in props && isRefFunction(props.ref)) {
      props.ref(current);
    }
  });
  return [ref, setRef];
}

// src/utils/state-props.ts
function toBooleanish(value) {
  return value ? "" : void 0;
}
function createARIADisabledState(disabled) {
  return {
    get disabled() {
      return disabled();
    },
    get "aria-disabled"() {
      return disabled();
    }
  };
}
function createARIAExpandedState(expanded) {
  return {
    get "aria-expanded"() {
      return expanded();
    }
  };
}
function createARIACheckedState(checked) {
  return {
    get "aria-checked"() {
      var _a;
      return (_a = checked()) != null ? _a : "mixed";
    }
  };
}
function createARIASelectedState(selected) {
  return {
    get "aria-selected"() {
      return selected();
    }
  };
}
function createARIAPressedState(pressed) {
  return {
    get "aria-pressed"() {
      return pressed();
    }
  };
}
function createDisabledState(disabled) {
  return {
    get "tc-disabled"() {
      return toBooleanish(disabled());
    }
  };
}
function createExpandedState(expanded) {
  return {
    get "tc-expanded"() {
      return toBooleanish(expanded());
    }
  };
}
function createCheckedState(isChecked) {
  return {
    get "tc-checked"() {
      const result = isChecked();
      return result == null ? "mixed" : toBooleanish(result);
    }
  };
}
function createSelectedState(isSelected) {
  return {
    get "tc-selected"() {
      return toBooleanish(isSelected());
    }
  };
}
function createActiveState(isActive) {
  return {
    get "tc-active"() {
      return toBooleanish(isActive());
    }
  };
}
function createMatchesState(matches) {
  return {
    get "tc-matches"() {
      return toBooleanish(matches());
    }
  };
}
function createHasSelectedState(hasSelected) {
  return {
    get "tc-has-selected"() {
      return toBooleanish(hasSelected());
    }
  };
}
function createHasActiveState(hasActive) {
  return {
    get "tc-has-active"() {
      return toBooleanish(hasActive());
    }
  };
}
function createHasQueryState(hasQuery) {
  return {
    get "tc-has-query"() {
      return toBooleanish(hasQuery());
    }
  };
}
function createPressedState(pressed) {
  return {
    get "tc-pressed"() {
      return toBooleanish(pressed());
    }
  };
}

// src/utils/use-event-listener.ts
import { onCleanup } from "solid-js";
function useEventListener(node, type, listener, options) {
  node.addEventListener(type, listener, options);
  onCleanup(() => {
    node.removeEventListener(type, listener, options);
  });
}
var use_event_listener_default = useEventListener;

// src/components/accordion/AccordionContext.ts
import { createContext as createContext2, createUniqueId, useContext as useContext2 } from "solid-js";

// src/utils/focus-query.ts
var QUERY = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex]:not([tabindex="-1"]), [contenteditable]';
function getFocusableElements(node, filter) {
  const nodes = node.querySelectorAll(QUERY);
  const replicated = [];
  for (let i = 0, len = nodes.length; i < len; i += 1) {
    if (!(filter && filter.contains(nodes[i]))) {
      replicated.push(nodes[i]);
    }
  }
  return replicated;
}

// src/utils/namespace.ts
var DATA_SET_NAMESPACE = "tc";
var TYPE_ATTRIBUTE = `${DATA_SET_NAMESPACE}-type`;
var DISABLED_NODE = `[${DATA_SET_NAMESPACE}-disabled]`;
var SELECTED_NODE = `[${DATA_SET_NAMESPACE}-selected]`;
var CHECKED_NODE = `[${DATA_SET_NAMESPACE}-checked]`;
var MATCHES_NODE = `[${DATA_SET_NAMESPACE}-matches]`;
function createTag(tag) {
  return {
    [TYPE_ATTRIBUTE]: tag
  };
}

// src/utils/virtual-focus.ts
import { onCleanup as onCleanup2 } from "solid-js";
var LISTENERS = /* @__PURE__ */ new Set();
function useVirtualFocus(listener) {
  LISTENERS.add(listener);
  onCleanup2(() => {
    LISTENERS.delete(listener);
  });
}
function focusVirtually(el) {
  for (const listener of LISTENERS.keys()) {
    listener(el);
  }
}

// src/utils/focus-navigation.ts
function isFocusable(el) {
  return !el.matches(DISABLED_NODE);
}
function getNextFocusable(nodes, anchor, direction, loop) {
  let current = anchor + direction;
  if (loop) {
    if (direction === 1 /* Next */ && current === nodes.length) {
      current = 0;
    }
    if (direction === -1 /* Prev */ && current === -1) {
      current = nodes.length - 1;
    }
    while (anchor !== current) {
      if (isFocusable(nodes[current])) {
        return nodes[current];
      }
      current += direction;
      if (direction === 1 /* Next */ && current >= nodes.length) {
        current = 0;
      }
      if (direction === -1 /* Prev */ && current < 0) {
        current = nodes.length - 1;
      }
    }
    return void 0;
  }
  while (current >= 0 && current < nodes.length) {
    if (isFocusable(nodes[current])) {
      return nodes[current];
    }
    current += direction;
  }
  return void 0;
}
function focusNode(node, virtual) {
  if (node) {
    if (virtual) {
      focusVirtually(node);
    } else {
      node.focus();
    }
  }
  return node;
}
function focusNext(nodes, targetNode, loop, virtual) {
  for (let i = 0, len = nodes.length; i < len; i += 1) {
    if (targetNode === nodes[i] || nodes[i].contains(targetNode)) {
      return focusNode(
        getNextFocusable(nodes, i, 1 /* Next */, loop),
        virtual
      );
    }
  }
  return void 0;
}
function focusPrev(nodes, targetNode, loop, virtual) {
  for (let i = 0, len = nodes.length; i < len; i += 1) {
    if (nodes[i].contains(targetNode)) {
      return focusNode(
        getNextFocusable(nodes, i, -1 /* Prev */, loop),
        virtual
      );
    }
  }
  return void 0;
}
function focusFirst(nodes, virtual) {
  if (nodes.length) {
    return focusNode(
      getNextFocusable(nodes, -1, 1 /* Next */, false),
      virtual
    );
  }
  return void 0;
}
function focusLast(nodes, virtual) {
  if (nodes.length) {
    return focusNode(
      getNextFocusable(nodes, nodes.length, -1 /* Prev */, false),
      virtual
    );
  }
  return void 0;
}
function focusMatch(nodes, character, virtual) {
  const lower = character.toLowerCase();
  for (let i = 0, l = nodes.length; i < l; i += 1) {
    const content = nodes[i].textContent;
    if (content != null && content.toLowerCase().startsWith(lower)) {
      return focusNode(nodes[i], virtual);
    }
  }
  return void 0;
}
function lockFocus(ref, reverse, virtual) {
  const nodes = getFocusableElements(ref);
  if (reverse) {
    if (!(document.activeElement && ref.contains(document.activeElement))) {
      return focusLast(nodes, virtual);
    }
    return focusPrev(
      nodes,
      document.activeElement,
      true,
      virtual
    );
  }
  if (!(document.activeElement && ref.contains(document.activeElement))) {
    return focusFirst(nodes, virtual);
  }
  return focusNext(nodes, document.activeElement, true, virtual);
}

// src/utils/focus-navigator.ts
var OWNER = `${DATA_SET_NAMESPACE}-owner`;
function queryNodes(el, ownerID, condition = "") {
  const query = `[${OWNER}="${ownerID}"]:not(${DISABLED_NODE})${condition}`;
  const nodes = el.querySelectorAll(query);
  return nodes;
}
function createOwnerAttribute(ownerID) {
  return {
    [OWNER]: ownerID
  };
}
var FocusNavigator = class {
  constructor(ownerID, options = {}) {
    var _a, _b;
    this.ownerID = ownerID;
    this.options = {
      virtual: (_a = options.virtual) != null ? _a : false,
      base: (_b = options.base) != null ? _b : ""
    };
  }
  setRef(ref) {
    this.internalRef = ref;
  }
  clearRef() {
    this.internalRef = void 0;
  }
  query(ref, condition = "") {
    return queryNodes(ref, this.ownerID, `${this.options.base}${condition}`);
  }
  setCurrent(node) {
    this.current = node;
  }
  setChecked(node) {
    this.current = focusNode(node, this.options.virtual);
  }
  setNextChecked(loop) {
    if (this.internalRef instanceof HTMLElement) {
      assert(this.current, new Error("missing current ref"));
      const current = focusNext(
        this.query(this.internalRef),
        this.current,
        loop,
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  setPrevChecked(loop) {
    if (this.internalRef instanceof HTMLElement) {
      assert(this.current, new Error("missing current ref"));
      const current = focusPrev(
        this.query(this.internalRef),
        this.current,
        loop,
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  setFirstChecked(condition = "") {
    if (this.internalRef instanceof HTMLElement) {
      const current = focusFirst(
        this.query(this.internalRef, condition),
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  setLastChecked(condition = "") {
    if (this.internalRef instanceof HTMLElement) {
      const current = focusLast(
        this.query(this.internalRef, condition),
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  setFirstMatch(character) {
    if (this.internalRef instanceof HTMLElement) {
      const current = focusMatch(
        this.query(this.internalRef),
        character,
        this.options.virtual
      );
      if (current) {
        this.current = current;
      }
    }
  }
  getId() {
    return this.ownerID;
  }
};

// src/components/accordion/AccordionContext.ts
var AccordionContext = createContext2();
function useAccordionContext(componentName) {
  const context = useContext2(AccordionContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Accordion>`)
  );
  return context;
}
function createAccordionFocusNavigator() {
  return new FocusNavigator(createUniqueId());
}

// src/components/accordion/tags.ts
var ACCORDION_TAG = createTag("accordion");
var ACCORDION_BUTTON_TAG = createTag("accordion-button");
var ACCORDION_HEADER_TAG = createTag("accordion-header");
var ACCORDION_ITEM_TAG = createTag("accordion-item");
var ACCORDION_PANEL_TAG = createTag("accordion-panel");

// src/components/accordion/Accordion.ts
function isAccordionUncontrolled(props) {
  return "defaultValue" in props;
}
function isAccordionMultiple(props) {
  return !!props.multiple;
}
function Accordion(props) {
  return createMemo2(() => {
    const state = isAccordionMultiple(props) ? createMultipleSelectState(props) : createSingleSelectState(props);
    const controller = createAccordionFocusNavigator();
    const [ref, setRef] = createForwardRef(props);
    createEffect2(() => {
      const current = ref();
      if (current instanceof HTMLElement) {
        controller.setRef(current);
        onCleanup3(() => {
          controller.clearRef();
        });
        use_event_listener_default(current, "keydown", (e) => {
          if (!state.disabled()) {
            switch (e.key) {
              case "ArrowUp": {
                e.preventDefault();
                controller.setPrevChecked(true);
                break;
              }
              case "ArrowDown": {
                e.preventDefault();
                controller.setNextChecked(true);
                break;
              }
              case "Home": {
                e.preventDefault();
                controller.setFirstChecked();
                break;
              }
              case "End": {
                e.preventDefault();
                controller.setLastChecked();
                break;
              }
              default:
                break;
            }
          }
        });
        use_event_listener_default(current, "focusin", (e) => {
          if (e.target && e.target !== current) {
            controller.setCurrent(e.target);
          }
        });
      }
    });
    return createComponent3(AccordionContext.Provider, {
      value: controller,
      get children() {
        return createDynamic(
          () => props.as || "div",
          mergeProps2(
            isAccordionUncontrolled(props) ? omitProps(props, [
              "as",
              "by",
              "children",
              "defaultValue",
              "disabled",
              "multiple",
              "onChange",
              "ref",
              "toggleable"
            ]) : omitProps(props, [
              "as",
              "by",
              "children",
              "value",
              "disabled",
              "multiple",
              "onChange",
              "ref",
              "toggleable"
            ]),
            ACCORDION_TAG,
            {
              ref: setRef,
              id: controller.getId()
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createHasSelectedState(() => state.hasSelected()),
            createHasActiveState(() => state.hasActive()),
            {
              get children() {
                return createComponent3(SelectStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    });
  });
}

// src/components/accordion/AccordionButton.ts
import { createComponent as createComponent5, createEffect as createEffect4, mergeProps as mergeProps4 } from "solid-js";
import { omitProps as omitProps3 } from "solid-use/props";

// src/states/create-select-option-state.ts
import {
  createComponent as createComponent4,
  createContext as createContext3,
  createMemo as createMemo3,
  untrack as untrack2,
  useContext as useContext3
} from "solid-js";
function createSelectOptionState(options) {
  const state = useSelectState();
  const isDisabled = createMemo3(() => options.disabled || state.disabled());
  return {
    isSelected: createMemo3(() => state.isSelected(options.value)),
    isActive: createMemo3(() => state.isActive(options.value)),
    select() {
      if (!untrack2(isDisabled)) {
        state.select(options.value);
      }
    },
    focus() {
      if (!untrack2(isDisabled)) {
        state.focus(options.value);
      }
    },
    blur() {
      if (!untrack2(isDisabled) && this.isActive()) {
        state.blur();
      }
    },
    disabled: isDisabled
  };
}
var SelectOptionStateContext = createContext3();
function SelectOptionStateProvider(props) {
  return createComponent4(SelectOptionStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useSelectOptionState() {
  const ctx = useContext3(SelectOptionStateContext);
  assert(ctx, new Error("Missing <SelectOptionStateProvider>"));
  return ctx;
}
function SelectOptionStateChild(props) {
  const state = useSelectOptionState();
  return createMemo3(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return createMemo3(() => current(state));
    }
    return current;
  });
}

// src/components/button/index.ts
import { createEffect as createEffect3, mergeProps as mergeProps3 } from "solid-js";
import { omitProps as omitProps2 } from "solid-use/props";
var BUTTON_TAG = createTag("button");
function Button(props) {
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect3(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      if (current.tagName !== "BUTTON") {
        use_event_listener_default(current, "keydown", (e) => {
          switch (e.key) {
            case "Enter":
            case " ": {
              current.click();
              break;
            }
          }
        });
      }
    }
  });
  return createDynamic(
    () => props.as || "button",
    mergeProps3(
      {
        get tabindex() {
          return props.disabled ? -1 : 0;
        },
        role: "button"
      },
      createDisabledState(() => props.disabled),
      createARIADisabledState(() => props.disabled),
      omitProps2(props, ["as", "ref"]),
      BUTTON_TAG,
      {
        ref: setInternalRef
      }
    )
  );
}

// src/components/accordion/AccordionItemContext.ts
import { createContext as createContext4, useContext as useContext4 } from "solid-js";
var AccordionItemContext = createContext4();
function useAccordionItemContext(componentName) {
  const context = useContext4(AccordionItemContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <AccordionItem>`)
  );
  return context;
}

// src/components/accordion/AccordionButton.ts
function AccordionButton(props) {
  const rootContext = useAccordionContext("AccordionButton");
  const itemContext = useAccordionItemContext("AccordionButton");
  const state = useSelectOptionState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => state.disabled() || props.disabled;
  createEffect4(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          state.select();
        }
      });
      use_event_listener_default(current, "focus", () => {
        if (!isDisabled()) {
          state.focus();
        }
      });
      use_event_listener_default(current, "blur", () => {
        if (!isDisabled()) {
          state.blur();
        }
      });
    }
  });
  return createComponent5(
    Button,
    mergeProps4(
      omitProps3(props, ["children", "ref", "disabled"]),
      ACCORDION_BUTTON_TAG,
      {
        id: itemContext.buttonID,
        ref: setInternalRef,
        get "aria-controls"() {
          return state.isSelected() && itemContext.panelID;
        }
      },
      createOwnerAttribute(rootContext.getId()),
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createSelectedState(() => state.isSelected()),
      createExpandedState(() => state.isSelected()),
      createARIAExpandedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      {
        get children() {
          return createComponent5(SelectOptionStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/accordion/AccordionHeader.ts
import { createComponent as createComponent6, mergeProps as mergeProps5 } from "solid-js";
import { omitProps as omitProps4 } from "solid-use/props";
function AccordionHeader(props) {
  useAccordionItemContext("AccordionHeader");
  const state = useSelectOptionState();
  return createDynamic(
    () => props.as || "h3",
    mergeProps5(
      omitProps4(props, ["as", "children"]),
      ACCORDION_HEADER_TAG,
      createDisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createExpandedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      {
        get children() {
          return createComponent6(SelectOptionStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/accordion/AccordionItem.ts
import { createComponent as createComponent7, createUniqueId as createUniqueId2, mergeProps as mergeProps6 } from "solid-js";
import { omitProps as omitProps5 } from "solid-use/props";
function AccordionItem(props) {
  useAccordionContext("AccordionItem");
  const buttonID = createUniqueId2();
  const panelID = createUniqueId2();
  const state = createSelectOptionState(props);
  return createComponent7(AccordionItemContext.Provider, {
    value: { buttonID, panelID },
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps6(
          omitProps5(props, ["as", "children", "value", "disabled"]),
          ACCORDION_ITEM_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createSelectedState(() => state.isSelected()),
          createExpandedState(() => state.isSelected()),
          createActiveState(() => state.isActive()),
          {
            get children() {
              return createComponent7(SelectOptionStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/accordion/AccordionPanel.ts
import { createComponent as createComponent8, mergeProps as mergeProps7 } from "solid-js";
import { omitProps as omitProps6 } from "solid-use/props";

// src/utils/create-unmountable.ts
import { children, createMemo as createMemo4 } from "solid-js";
function createUnmountable(props, shouldMount, render) {
  const mode = createMemo4(() => props.unmount == null ? true : props.unmount);
  return createMemo4(() => {
    const currentMode = mode();
    if (currentMode === "offscreen") {
      const condition = createMemo4(() => shouldMount());
      const current = children(() => render());
      return createMemo4(() => condition() && current);
    }
    if (currentMode) {
      const condition = createMemo4(() => shouldMount());
      return createMemo4(() => condition() && render);
    }
    return render;
  });
}

// src/components/accordion/AccordionPanel.ts
function AccordionPanel(props) {
  const context = useAccordionItemContext("AccordionPanel");
  const state = useSelectOptionState();
  return createUnmountable(
    props,
    () => state.isSelected(),
    () => createDynamic(
      () => props.as || "div",
      mergeProps7(
        omitProps6(props, ["as", "children", "unmount"]),
        ACCORDION_PANEL_TAG,
        {
          id: context.panelID,
          "aria-labelledby": context.buttonID
        },
        createDisabledState(() => state.disabled()),
        createSelectedState(() => state.isSelected()),
        createExpandedState(() => state.isSelected()),
        createActiveState(() => state.isActive()),
        {
          get children() {
            return createComponent8(SelectOptionStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        }
      )
    )
  );
}

// src/components/alert/index.ts
import { createUniqueId as createUniqueId3, mergeProps as mergeProps8 } from "solid-js";
import { omitProps as omitProps7 } from "solid-use/props";
var ALERT_TAG = createTag("alert");
function Alert(props) {
  const alertID = createUniqueId3();
  return createDynamic(
    () => props.as || "div",
    mergeProps8(
      {
        id: alertID
      },
      omitProps7(props, ["as"]),
      ALERT_TAG,
      {
        role: "alert"
      }
    )
  );
}

// src/components/alert-dialog/AlertDialog.ts
import {
  createComponent as createComponent10,
  createEffect as createEffect5,
  createUniqueId as createUniqueId4,
  mergeProps as mergeProps9
} from "solid-js";
import { omitProps as omitProps8 } from "solid-use/props";

// src/states/create-disclosure-state.ts
import {
  createComponent as createComponent9,
  createContext as createContext5,
  createMemo as createMemo5,
  createSignal as createSignal3,
  untrack as untrack3,
  useContext as useContext5
} from "solid-js";
function createDisclosureState(options) {
  let signal;
  let setSignal;
  if ("defaultOpen" in options) {
    const [isOpen, setIsOpen] = createSignal3(options.defaultOpen);
    signal = isOpen;
    setSignal = (value) => {
      setIsOpen(value);
      if (value && options.onOpen) {
        options.onOpen();
      }
      if (options.onChange) {
        options.onChange(value);
      }
      if (!value && options.onClose) {
        options.onClose();
      }
    };
  } else {
    signal = createMemo5(() => options.isOpen);
    setSignal = (value) => {
      if (value && options.onOpen) {
        options.onOpen();
      }
      if (options.onChange) {
        options.onChange(value);
      }
      if (!value && options.onClose) {
        options.onClose();
      }
    };
  }
  const isDisabled = createMemo5(() => !!options.disabled);
  return {
    isOpen() {
      return signal();
    },
    setState(value) {
      if (!untrack3(isDisabled)) {
        setSignal(value);
      }
    },
    disabled: isDisabled,
    open() {
      if (!untrack3(isDisabled)) {
        setSignal(true);
      }
    },
    close() {
      if (!untrack3(isDisabled)) {
        setSignal(false);
      }
    },
    toggle() {
      if (!untrack3(isDisabled)) {
        setSignal(!untrack3(signal));
      }
    }
  };
}
var DisclosureStateContext = createContext5();
function DisclosureStateProvider(props) {
  return createComponent9(DisclosureStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useDisclosureState() {
  const ctx = useContext5(DisclosureStateContext);
  assert(ctx, new Error("Missing <DisclosureStateProvider>"));
  return ctx;
}
function DisclosureStateChild(props) {
  const state = useDisclosureState();
  return createMemo5(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return createMemo5(() => current(state));
    }
    return current;
  });
}

// src/utils/use-focus-start-point.ts
import { onCleanup as onCleanup4 } from "solid-js";
import { isServer } from "solid-js/web";

// src/utils/focus-start-point.ts
function getFocusStartPoint() {
  const selection = window.getSelection();
  if (selection) {
    const node = selection.focusNode;
    if (node) {
      return node.parentElement;
    }
  }
  return void 0;
}
function setFocusStartPoint(element) {
  if (element) {
    const tabindex = element.getAttribute("tabindex");
    element.setAttribute("tabindex", "-1");
    element.focus();
    element.blur();
    if (tabindex) {
      element.setAttribute("tabindex", tabindex);
    } else {
      element.removeAttribute("tabindex");
    }
  }
}

// src/utils/use-focus-start-point.ts
var FocusStartPoint = class {
  constructor() {
    if (!isServer) {
      this.returnElement = document.activeElement;
      this.fsp = getFocusStartPoint();
      onCleanup4(() => {
        this.load();
      });
    }
  }
  load() {
    if (this.returnElement instanceof HTMLElement) {
      this.returnElement.focus();
    } else {
      setFocusStartPoint(this.fsp);
    }
  }
  save() {
    this.returnElement = document.activeElement;
    this.fsp = getFocusStartPoint();
  }
};
function useFocusStartPoint() {
  return new FocusStartPoint();
}

// src/components/alert-dialog/AlertDialogContext.ts
import { createContext as createContext6, useContext as useContext6 } from "solid-js";
var AlertDialogContext = createContext6();
function useAlertDialogContext(componentName) {
  const context = useContext6(AlertDialogContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <AlertDialog>`)
  );
  return context;
}

// src/components/alert-dialog/tags.ts
var ALERT_DIALOG_TAG = createTag("alert-dialog");
var ALERT_DIALOG_DESCRIPTION_TAG = createTag(
  "alert-dialog-description"
);
var ALERT_DIALOG_OVERLAY_TAG = createTag("alert-dialog-overlay");
var ALERT_DIALOG_PANEL_TAG = createTag("alert-dialog-panel");
var ALERT_DIALOG_TITLE_TAG = createTag("alert-dialog-title");

// src/components/alert-dialog/AlertDialog.ts
function isAlertDialogUncontrolled(props) {
  return "defaultOpen" in props;
}
function AlertDialog(props) {
  const ownerID = createUniqueId4();
  const panelID = createUniqueId4();
  const titleID = createUniqueId4();
  const descriptionID = createUniqueId4();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  createEffect5(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  return createComponent10(AlertDialogContext.Provider, {
    value: {
      ownerID,
      panelID,
      titleID,
      descriptionID
    },
    get children() {
      return createUnmountable(
        props,
        () => state.isOpen(),
        () => createDynamic(
          () => props.as || "div",
          mergeProps9(
            isAlertDialogUncontrolled(props) ? omitProps8(props, [
              "as",
              "children",
              "defaultOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]) : omitProps8(props, [
              "as",
              "children",
              "isOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]),
            ALERT_DIALOG_TAG,
            {
              id: ownerID,
              role: "alertdialog",
              "aria-modal": true,
              "aria-labelledby": titleID,
              "aria-describedby": descriptionID,
              get children() {
                return createComponent10(DisclosureStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createExpandedState(() => state.isOpen())
          )
        )
      );
    }
  });
}

// src/components/alert-dialog/AlertDialogDescription.ts
import { createComponent as createComponent11, mergeProps as mergeProps10 } from "solid-js";
import { omitProps as omitProps9 } from "solid-use/props";
function AlertDialogDescription(props) {
  const context = useAlertDialogContext("AlertDialogDescription");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "p",
    mergeProps10(
      omitProps9(props, ["as", "children"]),
      ALERT_DIALOG_DESCRIPTION_TAG,
      {
        id: context.descriptionID,
        get children() {
          return createComponent11(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/alert-dialog/AlertDialogOverlay.ts
import { createComponent as createComponent12, createEffect as createEffect6, mergeProps as mergeProps11 } from "solid-js";
import { omitProps as omitProps10 } from "solid-use/props";
function AlertDialogOverlay(props) {
  useAlertDialogContext("AlertDialogOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect6(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps11(
      omitProps10(props, ["as", "children", "ref"]),
      ALERT_DIALOG_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return createComponent12(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/alert-dialog/AlertDialogPanel.ts
import { createComponent as createComponent13, createEffect as createEffect7, mergeProps as mergeProps12 } from "solid-js";
import { omitProps as omitProps11 } from "solid-use/props";
function AlertDialogPanel(props) {
  const context = useAlertDialogContext("AlertDialogPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect7(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      if (state.isOpen()) {
        focusFirst(getFocusableElements(current), false);
        use_event_listener_default(current, "keydown", (e) => {
          if (!props.disabled) {
            switch (e.key) {
              case "Tab": {
                e.preventDefault();
                lockFocus(current, e.shiftKey, false);
                break;
              }
              case "Escape": {
                state.close();
                break;
              }
              default:
                break;
            }
          }
        });
      }
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps12(
      omitProps11(props, ["as", "children", "ref"]),
      ALERT_DIALOG_PANEL_TAG,
      {
        id: context.panelID,
        ref: setInternalRef,
        get children() {
          return createComponent13(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/alert-dialog/AlertDialogTitle.ts
import { createComponent as createComponent14, mergeProps as mergeProps13 } from "solid-js";
import { omitProps as omitProps12 } from "solid-use/props";
function AlertDialogTitle(props) {
  const context = useAlertDialogContext("AlertDialogTitle");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "h2",
    mergeProps13(
      omitProps12(props, ["as", "children"]),
      ALERT_DIALOG_TITLE_TAG,
      {
        id: context.titleID,
        get children() {
          return createComponent14(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/checkbox/Checkbox.ts
import { createComponent as createComponent16, createUniqueId as createUniqueId5, mergeProps as mergeProps14 } from "solid-js";
import { omitProps as omitProps13 } from "solid-use/props";

// src/states/create-check-state.ts
import {
  createComponent as createComponent15,
  createContext as createContext7,
  createMemo as createMemo6,
  createSignal as createSignal4,
  untrack as untrack4,
  useContext as useContext7
} from "solid-js";
function createCheckState(options) {
  let signal;
  let setSignal;
  if ("defaultChecked" in options) {
    const [isOpen, setIsOpen] = createSignal4(
      options.defaultChecked
    );
    signal = isOpen;
    setSignal = (value) => {
      setIsOpen(value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    signal = createMemo6(() => options.checked);
    setSignal = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = createMemo6(() => !!options.disabled);
  return {
    checked() {
      return signal();
    },
    setState(value) {
      if (!untrack4(isDisabled)) {
        setSignal(value);
      }
    },
    disabled: isDisabled,
    check() {
      if (!untrack4(isDisabled)) {
        setSignal(true);
      }
    },
    uncheck() {
      if (!untrack4(isDisabled)) {
        setSignal(false);
      }
    },
    reset() {
      if (!untrack4(isDisabled)) {
        setSignal(void 0);
      }
    },
    toggle() {
      if (!untrack4(isDisabled)) {
        setSignal(!untrack4(signal));
      }
    }
  };
}
var CheckStateContext = createContext7();
function CheckStateProvider(props) {
  return createComponent15(CheckStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useCheckState() {
  const ctx = useContext7(CheckStateContext);
  assert(ctx, new Error("Missing <CheckStateProvider>"));
  return ctx;
}
function CheckStateChild(props) {
  const state = useCheckState();
  return createMemo6(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return createMemo6(() => current(state));
    }
    return current;
  });
}

// src/components/checkbox/CheckboxContext.ts
import { createContext as createContext8, useContext as useContext8 } from "solid-js";
var CheckboxContext = createContext8();
function useCheckboxContext(componentName) {
  const context = useContext8(CheckboxContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Checkbox>`)
  );
  return context;
}

// src/components/checkbox/tags.ts
var CHECKBOX_TAG = createTag("checkbox");
var CHECKBOX_DESCRIPTION = createTag("checkbox-description");
var CHECKBOX_INDICATOR = createTag("checkbox-indicator");
var CHECKBOX_LABEL = createTag("checkbox-label");

// src/components/checkbox/Checkbox.ts
function isCheckboxUncontrolled(props) {
  return "defaultChecked" in props;
}
function Checkbox(props) {
  const ownerID = createUniqueId5();
  const labelID = createUniqueId5();
  const indicatorID = createUniqueId5();
  const descriptionID = createUniqueId5();
  const state = createCheckState(props);
  return createComponent16(CheckboxContext.Provider, {
    value: {
      ownerID,
      labelID,
      indicatorID,
      descriptionID
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps14(
          isCheckboxUncontrolled(props) ? omitProps13(props, [
            "as",
            "children",
            "defaultChecked",
            "disabled",
            "onChange"
          ]) : omitProps13(props, [
            "as",
            "children",
            "checked",
            "disabled",
            "onChange"
          ]),
          CHECKBOX_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createCheckedState(() => state.checked()),
          {
            get children() {
              return createComponent16(CheckStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/checkbox/CheckboxDescription.ts
import { createComponent as createComponent17, mergeProps as mergeProps15 } from "solid-js";
import { omitProps as omitProps14 } from "solid-use/props";
function CheckboxDescription(props) {
  const context = useCheckboxContext("CheckboxDescription");
  const state = useCheckState();
  return createDynamic(
    () => props.as || "p",
    mergeProps15(
      omitProps14(props, ["as", "children"]),
      CHECKBOX_DESCRIPTION,
      {
        id: context.descriptionID,
        get children() {
          return createComponent17(CheckStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createCheckedState(() => state.checked())
    )
  );
}

// src/components/checkbox/CheckboxIndicator.ts
import { createComponent as createComponent18, createEffect as createEffect8, mergeProps as mergeProps16 } from "solid-js";
import { omitProps as omitProps15 } from "solid-use/props";
function CheckboxIndicator(props) {
  const context = useCheckboxContext("CheckboxIndicator");
  const state = useCheckState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect8(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.toggle();
      });
    }
  });
  return createComponent18(
    Button,
    mergeProps16(
      omitProps15(props, ["children", "ref"]),
      CHECKBOX_INDICATOR,
      {
        id: context.indicatorID,
        role: "checkbox",
        "aria-labelledby": context.labelID,
        "aria-describedby": context.descriptionID,
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createCheckedState(() => state.checked()),
      {
        get children() {
          return createComponent18(CheckStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/checkbox/CheckboxLabel.ts
import { createComponent as createComponent19, mergeProps as mergeProps17 } from "solid-js";
import { omitProps as omitProps16 } from "solid-use/props";
function CheckboxLabel(props) {
  const context = useCheckboxContext("CheckboxLabel");
  const state = useCheckState();
  return createDynamic(
    () => props.as || "label",
    mergeProps17(
      omitProps16(props, ["as", "children"]),
      CHECKBOX_LABEL,
      {
        id: context.labelID,
        for: context.indicatorID,
        get children() {
          return createComponent19(CheckStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createCheckedState(() => state.checked())
    )
  );
}

// src/components/color-scheme/index.ts
import {
  createComponent as createComponent20,
  createContext as createContext9,
  createEffect as createEffect9,
  createMemo as createMemo7,
  createSignal as createSignal5,
  useContext as useContext9
} from "solid-js";
import { usePrefersDark } from "solid-use/media-query";
import usePageVisibility from "solid-use/page-visibility";
var ColorSchemeContext = createContext9();
var STORAGE_KEY = "theme-preference";
function ColorSchemeProvider(props) {
  let get;
  let set;
  if ("initialValue" in props) {
    const [scheme, setScheme] = createSignal5(props.initialValue);
    get = scheme;
    set = (value) => {
      setScheme(value);
      if (props.onChange) {
        props.onChange(value);
      }
    };
  } else {
    get = () => props.value;
    set = (value) => {
      if (props.onChange) {
        props.onChange(value);
      }
    };
  }
  const prefersDark = usePrefersDark();
  const isVisible = usePageVisibility();
  const shouldToggle = createMemo7(
    () => get() === "system" && prefersDark() || get() === "dark"
  );
  createEffect9(() => {
    isVisible();
    const onChange = () => {
      const value = localStorage.getItem(STORAGE_KEY);
      if (value) {
        set(value);
      } else {
        set("system");
      }
    };
    onChange();
    use_event_listener_default(window, "storage", onChange, false);
  });
  createEffect9(() => {
    localStorage.setItem(STORAGE_KEY, get());
  });
  createEffect9(() => {
    document.documentElement.classList.toggle("dark", shouldToggle());
  });
  return createComponent20(ColorSchemeContext.Provider, {
    value: {
      get value() {
        return get();
      },
      setValue(val) {
        set(val);
      },
      get preferred() {
        return shouldToggle() ? "dark" : "light";
      },
      get native() {
        return prefersDark() ? "dark" : "light";
      }
    },
    get children() {
      return props.children;
    }
  });
}
function useColorSchemeContext() {
  const ctx = useContext9(ColorSchemeContext);
  assert(ctx, new Error("Missing <ColorSchemeProvider>"));
  return ctx;
}
function useColorScheme() {
  const ctx = useColorSchemeContext();
  return [() => ctx.value, ctx.setValue];
}
function useNativeColorScheme() {
  const ctx = useColorSchemeContext();
  return () => ctx.native;
}
function usePreferredColorScheme() {
  const ctx = useColorSchemeContext();
  return () => ctx.preferred;
}

// src/components/combobox/Combobox.ts
import {
  createComponent as createComponent22,
  createEffect as createEffect10,
  createMemo as createMemo9,
  createSignal as createSignal8,
  createUniqueId as createUniqueId7,
  mergeProps as mergeProps18
} from "solid-js";
import { omitProps as omitProps17 } from "solid-use/props";

// src/states/create-autocomplete-state.ts
import {
  createComponent as createComponent21,
  createContext as createContext10,
  createMemo as createMemo8,
  createSignal as createSignal7,
  untrack as untrack5,
  useContext as useContext10
} from "solid-js";

// src/utils/create-input-reader.ts
import { createSignal as createSignal6, onCleanup as onCleanup5 } from "solid-js";
var INPUT_READER_DEBOUNCE_TIMEOUT = 250;
function createInputReader(time = INPUT_READER_DEBOUNCE_TIMEOUT) {
  let timeout;
  onCleanup5(() => {
    if (timeout) {
      clearTimeout(timeout);
    }
  });
  const [signal, setSignal] = createSignal6("");
  return [
    signal,
    (value) => {
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        setSignal(value);
      }, time);
    }
  ];
}

// src/states/create-autocomplete-state.ts
function createSingleAutocompleteState(options) {
  const [active, setActive] = createSignal7();
  let selectedValue;
  let setSelectedValue;
  const equals = options.by || isEqual;
  if ("defaultValue" in options) {
    const [selected, setSelected] = createSignal7(
      options.defaultValue
    );
    selectedValue = selected;
    setSelectedValue = (value) => {
      setSelected(() => value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    selectedValue = createMemo8(() => options.value);
    setSelectedValue = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = createMemo8(() => !!options.disabled);
  const [input, setInput] = createInputReader();
  return {
    isSelected(value) {
      return isEqual(value, selectedValue());
    },
    select(value) {
      if (!untrack5(isDisabled)) {
        if (options.toggleable && equals(untrack5(selectedValue), value)) {
          setSelectedValue(void 0);
        } else {
          setSelectedValue(value);
        }
      }
    },
    hasSelected() {
      return selectedValue() != null;
    },
    disabled: isDisabled,
    hasActive() {
      return !!active();
    },
    isActive(value) {
      const ref = active();
      return ref ? equals(value, ref.value) : false;
    },
    focus(value) {
      if (!untrack5(isDisabled)) {
        setActive({
          value
        });
      }
    },
    blur() {
      if (!untrack5(isDisabled)) {
        setActive(void 0);
      }
    },
    query() {
      return input();
    },
    setQuery(value) {
      if (!untrack5(isDisabled)) {
        setInput(value);
      }
    },
    matches(value) {
      return options.matchBy(value, input());
    },
    hasQuery: createMemo8(() => !!input())
  };
}
function createMultipleAutocompleteState(options) {
  const [active, setActive] = createSignal7();
  let selectedValues;
  let setSelectedValues;
  const equals = options.by || isEqual;
  if ("defaultValue" in options) {
    const [selected, setSelected] = createSignal7(options.defaultValue);
    selectedValues = selected;
    setSelectedValues = (value) => {
      setSelected(() => value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    selectedValues = createMemo8(() => options.value);
    setSelectedValues = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = createMemo8(() => !!options.disabled);
  const [input, setInput] = createInputReader();
  return {
    isSelected(value) {
      const values = selectedValues();
      for (let i = 0, len = values.length; i < len; i += 1) {
        if (equals(value, values[i])) {
          return true;
        }
      }
      return false;
    },
    select(value) {
      if (!untrack5(isDisabled)) {
        const newValues = [];
        const currentValues = untrack5(selectedValues);
        let hasValue = false;
        for (let i = 0, len = currentValues.length; i < len; i += 1) {
          const item = currentValues[i];
          const isSame = equals(item, value);
          if (isSame) {
            hasValue = true;
          }
          if (!(options.toggleable && isSame)) {
            newValues.push(item);
          }
        }
        if (!hasValue) {
          newValues.push(value);
        }
        setSelectedValues(newValues);
      }
    },
    hasSelected: createMemo8(() => selectedValues().length > 0),
    disabled: isDisabled,
    hasActive: createMemo8(() => !!active()),
    isActive(value) {
      const ref = active();
      if (ref) {
        return equals(value, ref.value);
      }
      return false;
    },
    focus(value) {
      if (!untrack5(isDisabled)) {
        setActive({
          value
        });
      }
    },
    blur() {
      if (!untrack5(isDisabled)) {
        setActive(void 0);
      }
    },
    query() {
      return input();
    },
    setQuery(value) {
      setInput(value);
    },
    matches(value) {
      return options.matchBy(value, input());
    },
    hasQuery: createMemo8(() => !!input())
  };
}
var AutocompleteStateContext = createContext10();
function AutocompleteStateProvider(props) {
  return createComponent21(AutocompleteStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useAutocompleteState() {
  const ctx = useContext10(AutocompleteStateContext);
  assert(ctx, new Error("Missing <AutocompleteStateProvider>"));
  return ctx;
}
function AutocompleteStateChild(props) {
  const state = useAutocompleteState();
  return createMemo8(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return createMemo8(() => current(state));
    }
    return current;
  });
}

// src/components/combobox/ComboboxContext.ts
import { createContext as createContext11, createUniqueId as createUniqueId6, useContext as useContext11 } from "solid-js";
var ComboboxContext = createContext11();
function useComboboxContext(componentName) {
  const context = useContext11(ComboboxContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Combobox>`)
  );
  return context;
}
function createComboboxOptionFocusNavigator() {
  return new FocusNavigator(createUniqueId6(), {
    virtual: true,
    base: MATCHES_NODE
  });
}

// src/components/combobox/tags.ts
var COMBOBOX_TAG = createTag("combobox");
var COMBOBOX_INPUT_TAG = createTag("combobox-input");
var COMBOBOX_OPTIONS_TAG = createTag("combobox-options");
var COMBOBOX_OPTION_TAG = createTag("combobox-option");
var COMBOBOX_LABEL_TAG = createTag("combobox-label");

// src/components/combobox/Combobox.ts
function isComboboxMultiple(props) {
  return !!props.multiple;
}
function isComboboxSelectUncontrolled(props) {
  return "defaultValue" in props;
}
function isComboboxDisclosureUncontrolled(props) {
  return "defaultOpen" in props;
}
function getProps(props) {
  if (isComboboxSelectUncontrolled(props)) {
    if (isComboboxDisclosureUncontrolled(props)) {
      return omitProps17(props, [
        "as",
        "by",
        "children",
        "defaultOpen",
        "defaultValue",
        "disabled",
        "matchBy",
        "multiple",
        "onClose",
        "onDisclosureChange",
        "onOpen",
        "onSelectChange",
        "toggleable"
      ]);
    }
    return omitProps17(props, [
      "as",
      "by",
      "children",
      "defaultValue",
      "disabled",
      "isOpen",
      "matchBy",
      "multiple",
      "onClose",
      "onDisclosureChange",
      "onOpen",
      "onSelectChange",
      "toggleable"
    ]);
  }
  if (isComboboxDisclosureUncontrolled(props)) {
    return omitProps17(props, [
      "as",
      "by",
      "children",
      "defaultOpen",
      "disabled",
      "matchBy",
      "multiple",
      "onClose",
      "onDisclosureChange",
      "onOpen",
      "onSelectChange",
      "toggleable",
      "value"
    ]);
  }
  return omitProps17(props, [
    "as",
    "by",
    "children",
    "disabled",
    "isOpen",
    "matchBy",
    "multiple",
    "onClose",
    "onDisclosureChange",
    "onOpen",
    "onSelectChange",
    "toggleable",
    "value"
  ]);
}
function Combobox(props) {
  return createMemo9(() => {
    const labelID = createUniqueId7();
    const inputID = createUniqueId7();
    const optionsID = createUniqueId7();
    const disclosureState = createDisclosureState(
      mergeProps18(props, {
        onChange(value) {
          if (props.onDisclosureChange) {
            props.onDisclosureChange(value);
          }
        }
      })
    );
    const autocompleteState = isComboboxMultiple(props) ? createMultipleAutocompleteState(
      mergeProps18(props, {
        onChange(value) {
          if (props.onSelectChange) {
            props.onSelectChange(value);
          }
        }
      })
    ) : createSingleAutocompleteState(
      mergeProps18(props, {
        onChange(value) {
          if (props.onSelectChange) {
            props.onSelectChange(value);
          }
        }
      })
    );
    const controller = createComboboxOptionFocusNavigator();
    const [activeDescendant, setActiveDescendant] = createSignal8();
    const [selectedDescendant, setSelectedDescendant] = createSignal8(void 0, {
      equals: false
    });
    createEffect10(() => {
      if (!autocompleteState.hasActive()) {
        setActiveDescendant(void 0);
      }
    });
    return createComponent22(ComboboxContext.Provider, {
      value: {
        get multiple() {
          return props.multiple;
        },
        labelID,
        inputID,
        optionsID,
        controller,
        inputHovering: false,
        optionsHovering: false,
        get activeDescendant() {
          return activeDescendant();
        },
        set activeDescendant(value) {
          setActiveDescendant(value);
        },
        get selectedDescendant() {
          return selectedDescendant();
        },
        set selectedDescendant(value) {
          setSelectedDescendant(value);
        }
      },
      get children() {
        return createComponent22(AutocompleteStateProvider, {
          state: autocompleteState,
          get children() {
            return createComponent22(DisclosureStateProvider, {
              state: disclosureState,
              get children() {
                return createDynamic(
                  () => props.as || "div",
                  mergeProps18(
                    getProps(props),
                    COMBOBOX_TAG,
                    {
                      "aria-labelledby": labelID,
                      get children() {
                        return props.children;
                      }
                    },
                    createDisabledState(() => autocompleteState.disabled()),
                    createARIADisabledState(() => autocompleteState.disabled()),
                    createHasSelectedState(
                      () => autocompleteState.hasSelected()
                    ),
                    createHasActiveState(() => autocompleteState.hasActive()),
                    createExpandedState(() => disclosureState.isOpen())
                  )
                );
              }
            });
          }
        });
      }
    });
  });
}

// src/components/combobox/ComboboxInput.ts
import { createEffect as createEffect11, mergeProps as mergeProps19, untrack as untrack6 } from "solid-js";
import { omitProps as omitProps18 } from "solid-use/props";

// src/components/command/tags.ts
var COMMAND_TAG = createTag("command");
var COMMAND_INPUT_TAG = createTag("command-input");
var COMMAND_OPTIONS_TAG = createTag("command-options");
var COMMAND_OPTION_TAG = createTag("command-option");
var COMMAND_LABEL_TAG = createTag("command-label");

// src/components/combobox/ComboboxInput.ts
function ComboboxInput(props) {
  const context = useComboboxContext("ComboboxInput");
  const autocompleteState = useAutocompleteState();
  const disclosureState = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => autocompleteState.disabled() || props.disabled;
  createEffect11(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      if (current instanceof HTMLInputElement) {
        use_event_listener_default(current, "input", () => {
          if (!isDisabled()) {
            autocompleteState.setQuery(current.value);
          }
        });
      }
      use_event_listener_default(current, "keydown", (e) => {
        if (!isDisabled()) {
          switch (e.key) {
            case "Escape": {
              disclosureState.close();
              break;
            }
            case "ArrowUp": {
              e.preventDefault();
              if (disclosureState.isOpen()) {
                context.controller.setPrevChecked(true);
              } else {
                disclosureState.open();
              }
              break;
            }
            case "ArrowDown": {
              e.preventDefault();
              if (disclosureState.isOpen()) {
                context.controller.setNextChecked(true);
              } else {
                disclosureState.open();
              }
              break;
            }
            case "Enter": {
              e.preventDefault();
              if (disclosureState.isOpen()) {
                context.selectedDescendant = context.activeDescendant;
              }
              break;
            }
            default:
              break;
          }
        }
      });
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          disclosureState.toggle();
        }
      });
      use_event_listener_default(current, "blur", (e) => {
        if (context.optionsHovering) {
          return;
        }
        autocompleteState.blur();
        if (!(e.relatedTarget && current.contains(e.relatedTarget))) {
          disclosureState.close();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.inputHovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.inputHovering = false;
      });
    }
  });
  createEffect11(() => {
    if (autocompleteState.query() !== "") {
      if (untrack6(() => disclosureState.isOpen())) {
        context.controller.setFirstChecked();
      } else {
        disclosureState.open();
      }
    }
  });
  createEffect11(() => {
    if (context.activeDescendant) {
      const current = document.getElementById(context.activeDescendant);
      if (current) {
        context.controller.setCurrent(current);
      }
    }
  });
  return createDynamic(
    () => props.as || "input",
    mergeProps19(
      omitProps18(props, ["as", "ref"]),
      {
        id: context.inputID,
        ref: setInternalRef,
        // Guarantee it's a text
        type: "text",
        // Guarantee it's interactive
        tabindex: 0,
        role: "combobox",
        // Controls the options listbox
        "aria-haspopup": "listbox",
        "aria-controls": context.optionsID,
        "aria-labelledby": context.labelID,
        get "aria-expanded"() {
          return disclosureState.isOpen();
        },
        get "aria-activedescendant"() {
          return context.activeDescendant;
        }
      },
      COMMAND_INPUT_TAG,
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createExpandedState(() => disclosureState.isOpen()),
      createARIAExpandedState(() => disclosureState.isOpen()),
      createHasSelectedState(() => autocompleteState.hasSelected()),
      createHasActiveState(() => autocompleteState.hasActive()),
      createHasQueryState(() => autocompleteState.hasQuery())
    )
  );
}

// src/components/combobox/ComboboxLabel.ts
import { mergeProps as mergeProps20 } from "solid-js";
import { omitProps as omitProps19 } from "solid-use/props";
function ComboboxLabel(props) {
  const context = useComboboxContext("ComboboxLabel");
  const autocompleteState = useAutocompleteState();
  const disclosureState = useDisclosureState();
  return createDynamic(
    () => props.as || "label",
    mergeProps20(
      omitProps19(props, ["as"]),
      COMBOBOX_LABEL_TAG,
      {
        id: context.labelID
      },
      createDisabledState(() => autocompleteState.disabled()),
      createExpandedState(() => disclosureState.isOpen()),
      createHasSelectedState(() => autocompleteState.hasSelected()),
      createHasActiveState(() => autocompleteState.hasActive()),
      createHasQueryState(() => autocompleteState.hasQuery())
    )
  );
}

// src/components/combobox/ComboboxOption.ts
import {
  createComponent as createComponent24,
  createEffect as createEffect12,
  createRenderEffect,
  createUniqueId as createUniqueId8,
  mergeProps as mergeProps21
} from "solid-js";
import { omitProps as omitProps20 } from "solid-use/props";

// src/states/create-autocomplete-option-state.ts
import {
  createComponent as createComponent23,
  createContext as createContext12,
  createMemo as createMemo10,
  untrack as untrack7,
  useContext as useContext12
} from "solid-js";
function createAutocompleteOptionState(options) {
  const state = useAutocompleteState();
  const isDisabled = createMemo10(() => options.disabled || state.disabled());
  return {
    isSelected: createMemo10(() => state.isSelected(options.value)),
    isActive: createMemo10(() => state.isActive(options.value)),
    select() {
      if (!untrack7(isDisabled)) {
        state.select(options.value);
      }
    },
    focus() {
      if (!untrack7(isDisabled)) {
        state.focus(options.value);
      }
    },
    blur() {
      if (!untrack7(isDisabled) && this.isActive()) {
        state.blur();
      }
    },
    matches: createMemo10(() => state.matches(options.value)),
    disabled: isDisabled
  };
}
var AutocompleteOptionStateContext = createContext12();
function AutocompleteOptionStateProvider(props) {
  return createComponent23(AutocompleteOptionStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}

// src/components/combobox/ComboboxOption.ts
function ComboboxOption(props) {
  const context = useComboboxContext("ComboboxOptions");
  const disclosure = useDisclosureState();
  const state = createAutocompleteOptionState(props);
  const [internalRef, setInternalRef] = createForwardRef(props);
  const id = createUniqueId8();
  createEffect12(() => {
    if (!state.disabled() && context.selectedDescendant === id) {
      state.select();
      if (!context.multiple) {
        disclosure.close();
      }
    }
  });
  function focusOption() {
    context.activeDescendant = id;
    state.focus();
  }
  createRenderEffect(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!state.disabled()) {
          state.select();
          focusOption();
          if (!context.multiple) {
            disclosure.close();
          }
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        if (!state.disabled()) {
          focusOption();
        }
      });
      use_event_listener_default(current, "mouseleave", () => {
        state.blur();
      });
      useVirtualFocus((el) => {
        if (el === current) {
          focusOption();
        }
      });
    }
  });
  return createComponent24(
    Button,
    mergeProps21(
      omitProps20(props, ["as", "children", "disabled", "value", "ref"]),
      COMBOBOX_OPTION_TAG,
      createOwnerAttribute(context.controller.getId()),
      {
        id,
        get as() {
          return props.as || "li";
        },
        role: "option",
        tabindex: -1,
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      createMatchesState(() => state.matches()),
      {
        get children() {
          return createComponent24(AutocompleteOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/combobox/ComboboxOptions.ts
import {
  createComponent as createComponent25,
  createEffect as createEffect13,
  mergeProps as mergeProps22,
  onCleanup as onCleanup6,
  onMount,
  untrack as untrack8
} from "solid-js";
import { omitProps as omitProps21 } from "solid-use/props";
function ComboboxOptions(props) {
  const context = useComboboxContext("ComboboxOptions");
  const autocompleteState = useAutocompleteState();
  const disclosureState = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect13(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.controller.setRef(current);
      onCleanup6(() => {
        context.controller.clearRef();
      });
      use_event_listener_default(current, "focusin", () => {
        if (context.anchor) {
          context.anchor.focus();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.optionsHovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.optionsHovering = false;
      });
    }
  });
  createEffect13(() => {
    if (!disclosureState.isOpen()) {
      setInternalRef(void 0);
    }
  });
  onMount(() => {
    createEffect13(() => {
      if (disclosureState.isOpen()) {
        if (untrack8(() => autocompleteState.hasSelected())) {
          context.controller.setFirstChecked(SELECTED_NODE);
        } else {
          context.controller.setFirstChecked();
        }
      }
    });
  });
  return createUnmountable(
    props,
    () => disclosureState.isOpen(),
    () => createDynamic(
      () => props.as || "ul",
      mergeProps22(
        omitProps21(props, ["as", "children", "ref"]),
        COMBOBOX_OPTIONS_TAG,
        {
          id: context.optionsID,
          role: "listbox",
          "aria-multiselectable": context.multiple,
          ref: setInternalRef,
          // TODO should Combobox support "horizontal"?
          "aria-orientation": "vertical",
          tabindex: -1
        },
        createDisabledState(() => autocompleteState.disabled()),
        createARIADisabledState(() => autocompleteState.disabled()),
        createExpandedState(() => disclosureState.isOpen()),
        createHasSelectedState(() => autocompleteState.hasSelected()),
        createHasActiveState(() => autocompleteState.hasActive()),
        createHasQueryState(() => autocompleteState.hasQuery()),
        {
          get children() {
            return createComponent25(AutocompleteStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        }
      )
    )
  );
}

// src/components/command/Command.ts
import {
  createComponent as createComponent26,
  createEffect as createEffect14,
  createMemo as createMemo11,
  createSignal as createSignal9,
  createUniqueId as createUniqueId10,
  mergeProps as mergeProps23
} from "solid-js";
import { omitProps as omitProps22 } from "solid-use/props";

// src/components/command/CommandContext.ts
import { createContext as createContext13, createUniqueId as createUniqueId9, useContext as useContext13 } from "solid-js";
var CommandContext = createContext13();
function useCommandContext(componentName) {
  const context = useContext13(CommandContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Command>`)
  );
  return context;
}
function createCommandOptionFocusNavigator() {
  return new FocusNavigator(createUniqueId9(), {
    virtual: true,
    base: MATCHES_NODE
  });
}

// src/components/command/Command.ts
function isCommandMultiple(props) {
  return !!props.multiple;
}
function isCommandUncontrolled(props) {
  return "defaultValue" in props;
}
function Command(props) {
  return createMemo11(() => {
    const controller = createCommandOptionFocusNavigator();
    const state = isCommandMultiple(props) ? createMultipleAutocompleteState(props) : createSingleAutocompleteState(props);
    const [activeDescendant, setActiveDescendant] = createSignal9();
    const [selectedDescendant, setSelectedDescendant] = createSignal9(void 0, {
      equals: false
    });
    const inputID = createUniqueId10();
    const optionsID = createUniqueId10();
    const labelID = createUniqueId10();
    createEffect14(() => {
      if (!state.hasActive()) {
        setActiveDescendant(void 0);
      }
    });
    return createComponent26(CommandContext.Provider, {
      value: {
        multiple: !!props.multiple,
        controller,
        get activeDescendant() {
          return activeDescendant();
        },
        set activeDescendant(value) {
          setActiveDescendant(value);
        },
        get selectedDescendant() {
          return selectedDescendant();
        },
        set selectedDescendant(value) {
          setSelectedDescendant(value);
        },
        inputID,
        optionsID,
        labelID,
        optionsHovering: false
      },
      get children() {
        return createDynamic(
          () => props.as || "div",
          mergeProps23(
            isCommandUncontrolled(props) ? omitProps22(props, [
              "as",
              "by",
              "children",
              "defaultValue",
              "disabled",
              "horizontal",
              "multiple",
              "onChange",
              "toggleable"
            ]) : omitProps22(props, [
              "as",
              "by",
              "children",
              "value",
              "disabled",
              "horizontal",
              "multiple",
              "onChange",
              "toggleable"
            ]),
            COMMAND_TAG,
            {
              id: controller.getId(),
              "aria-labelledby": labelID
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createHasSelectedState(() => state.hasSelected()),
            createHasActiveState(() => state.hasActive()),
            createHasQueryState(() => state.hasQuery()),
            {
              get children() {
                return createComponent26(AutocompleteStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    });
  });
}

// src/components/command/CommandInput.ts
import { createEffect as createEffect15, mergeProps as mergeProps24 } from "solid-js";
import { omitProps as omitProps23 } from "solid-use/props";
function CommandInput(props) {
  const context = useCommandContext("CommandInput");
  const state = useAutocompleteState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => state.disabled() || props.disabled;
  createEffect15(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      if (current instanceof HTMLInputElement) {
        use_event_listener_default(current, "input", () => {
          if (!isDisabled()) {
            state.setQuery(current.value);
          }
        });
      }
      use_event_listener_default(current, "keydown", (e) => {
        if (!isDisabled()) {
          switch (e.key) {
            case "ArrowUp": {
              e.preventDefault();
              context.controller.setPrevChecked(true);
              break;
            }
            case "ArrowDown": {
              e.preventDefault();
              context.controller.setNextChecked(true);
              break;
            }
            case "Enter": {
              e.preventDefault();
              context.selectedDescendant = context.activeDescendant;
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "focus", () => {
        if (context.activeDescendant) {
          const ref = document.getElementById(context.activeDescendant);
          if (ref) {
            context.controller.setCurrent(ref);
          }
        } else if (state.hasSelected()) {
          context.controller.setFirstChecked(SELECTED_NODE);
        } else {
          context.controller.setFirstChecked();
        }
      });
      use_event_listener_default(current, "blur", () => {
        if (!context.optionsHovering) {
          state.blur();
        }
      });
    }
  });
  createEffect15(() => {
    if (state.query() !== "") {
      context.controller.setFirstChecked();
    }
  });
  createEffect15(() => {
    if (context.activeDescendant) {
      const ref = document.getElementById(context.activeDescendant);
      if (ref) {
        context.controller.setCurrent(ref);
      }
    }
  });
  return createDynamic(
    () => props.as || "input",
    mergeProps24(
      omitProps23(props, ["as", "ref"]),
      {
        id: context.inputID,
        ref: setInternalRef,
        // Guarantee it's a text
        type: "text",
        // Guarantee it's interactive
        tabindex: 0,
        role: "combobox",
        // Controls the options listbox
        "aria-controls": context.optionsID,
        // Since combobox roles have aria-expanded=false
        // as default but Command has a visible listbox
        // we set this to true
        "aria-expanded": true,
        get "aria-activedescendant"() {
          return context.activeDescendant;
        }
      },
      COMMAND_INPUT_TAG,
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createHasSelectedState(() => state.hasSelected()),
      createHasActiveState(() => state.hasActive()),
      createHasQueryState(() => state.hasQuery())
    )
  );
}

// src/components/command/CommandLabel.ts
import { mergeProps as mergeProps25 } from "solid-js";
import { omitProps as omitProps24 } from "solid-use/props";
function CommandLabel(props) {
  const context = useCommandContext("CommandLabel");
  const state = useAutocompleteState();
  return createDynamic(
    () => props.as || "label",
    mergeProps25(
      omitProps24(props, ["as"]),
      COMMAND_LABEL_TAG,
      {
        id: context.labelID
      },
      createDisabledState(() => state.disabled()),
      createHasSelectedState(() => state.hasSelected()),
      createHasActiveState(() => state.hasActive()),
      createHasQueryState(() => state.hasQuery())
    )
  );
}

// src/components/command/CommandOption.ts
import {
  createComponent as createComponent27,
  createEffect as createEffect16,
  createUniqueId as createUniqueId11,
  mergeProps as mergeProps26
} from "solid-js";
import { omitProps as omitProps25 } from "solid-use/props";
function CommandOption(props) {
  const context = useCommandContext("CommandOption");
  const [internalRef, setInternalRef] = createForwardRef(props);
  const state = createAutocompleteOptionState(props);
  const id = createUniqueId11();
  createEffect16(() => {
    if (!state.disabled() && context.selectedDescendant === id) {
      state.select();
    }
  });
  function focusOption() {
    context.activeDescendant = id;
    state.focus();
  }
  createEffect16(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!state.disabled()) {
          state.select();
          focusOption();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        if (!state.disabled()) {
          focusOption();
        }
      });
      use_event_listener_default(current, "mouseleave", () => {
        state.blur();
      });
      useVirtualFocus((el) => {
        if (el === current) {
          focusOption();
        }
      });
    }
  });
  return createComponent27(
    Button,
    mergeProps26(
      omitProps25(props, ["as", "children", "value", "ref"]),
      COMMAND_OPTION_TAG,
      createOwnerAttribute(context.controller.getId()),
      {
        id,
        get as() {
          return props.as || "li";
        },
        role: "option",
        tabindex: -1,
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      createMatchesState(() => state.matches()),
      {
        get children() {
          return createComponent27(AutocompleteOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/command/CommandOptions.ts
import { createComponent as createComponent28, createEffect as createEffect17, mergeProps as mergeProps27, onCleanup as onCleanup7 } from "solid-js";
import { omitProps as omitProps26 } from "solid-use/props";
function CommandOptions(props) {
  const context = useCommandContext("CommandOptions");
  const state = useAutocompleteState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect17(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.controller.setRef(current);
      onCleanup7(() => {
        context.controller.clearRef();
      });
      use_event_listener_default(current, "focusin", () => {
        if (context.anchor) {
          context.anchor.focus();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.optionsHovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.optionsHovering = false;
      });
    }
  });
  return createDynamic(
    () => props.as || "ul",
    mergeProps27(
      omitProps26(props, ["as", "children", "ref"]),
      COMMAND_OPTIONS_TAG,
      {
        id: context.optionsID,
        role: "listbox",
        "aria-multiselectable": context.multiple,
        ref: setInternalRef,
        // TODO should Command support "horizontal"?
        "aria-orientation": "vertical",
        tabindex: -1
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createHasSelectedState(() => state.hasSelected()),
      createHasActiveState(() => state.hasActive()),
      createHasQueryState(() => state.hasQuery()),
      {
        get children() {
          return createComponent28(AutocompleteStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/command-bar/CommandBar.ts
import {
  createComponent as createComponent29,
  createEffect as createEffect18,
  createUniqueId as createUniqueId12,
  mergeProps as mergeProps28
} from "solid-js";
import { omitProps as omitProps27 } from "solid-use/props";

// src/components/command-bar/CommandBarContext.ts
import { createContext as createContext14, useContext as useContext14 } from "solid-js";
var CommandBarContext = createContext14();
function useCommandBarContext(componentName) {
  const context = useContext14(CommandBarContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <CommandBar>`)
  );
  return context;
}

// src/components/command-bar/tags.ts
var COMMAND_BAR_TAG = createTag("command-bar");
var COMMAND_BAR_DESCRIPTION_TAG = createTag("command-bar-description");
var COMMAND_BAR_OVERLAY_TAG = createTag("command-bar-overlay");
var COMMAND_BAR_PANEL_TAG = createTag("command-bar-panel");
var COMMAND_BAR_TITLE_TAG = createTag("command-bar-title");

// src/components/command-bar/CommandBar.ts
function isCommandBarUncontrolled(props) {
  return "defaultOpen" in props;
}
function CommandBar(props) {
  const ownerID = createUniqueId12();
  const panelID = createUniqueId12();
  const titleID = createUniqueId12();
  const descriptionID = createUniqueId12();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  createEffect18(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  createEffect18(() => {
    use_event_listener_default(window, "keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "k" && !e.defaultPrevented) {
        e.preventDefault();
        state.open();
      }
    });
  });
  return createComponent29(CommandBarContext.Provider, {
    value: {
      ownerID,
      panelID,
      titleID,
      descriptionID
    },
    get children() {
      return createUnmountable(
        props,
        () => state.isOpen(),
        () => createDynamic(
          () => props.as || "div",
          mergeProps28(
            isCommandBarUncontrolled(props) ? omitProps27(props, [
              "as",
              "children",
              "defaultOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]) : omitProps27(props, [
              "as",
              "children",
              "isOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]),
            {
              id: ownerID,
              role: "dialog",
              "aria-modal": true,
              "aria-labelledby": titleID,
              "aria-describedby": descriptionID
            },
            COMMAND_BAR_TAG,
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createExpandedState(() => state.isOpen()),
            {
              get children() {
                return createComponent29(DisclosureStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        )
      );
    }
  });
}

// src/components/command-bar/CommandBarDescription.ts
import { createComponent as createComponent30, mergeProps as mergeProps29 } from "solid-js";
import { omitProps as omitProps28 } from "solid-use/props";
function CommandBarDescription(props) {
  const context = useCommandBarContext("CommandBarDescription");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "p",
    mergeProps29(
      omitProps28(props, ["as", "children"]),
      COMMAND_BAR_DESCRIPTION_TAG,
      {
        id: context.descriptionID,
        get children() {
          return createComponent30(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/command-bar/CommandBarOverlay.ts
import { createComponent as createComponent31, createEffect as createEffect19, mergeProps as mergeProps30 } from "solid-js";
import { omitProps as omitProps29 } from "solid-use/props";
function CommandBarOverlay(props) {
  useCommandBarContext("CommandBarOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect19(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps30(
      omitProps29(props, ["as", "children", "ref"]),
      COMMAND_BAR_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return createComponent31(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/command-bar/CommandBarPanel.ts
import { createComponent as createComponent32, createEffect as createEffect20, mergeProps as mergeProps31 } from "solid-js";
import { omitProps as omitProps30 } from "solid-use/props";
function CommandBarPanel(props) {
  const context = useCommandBarContext("CommandBarPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect20(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      if (state.isOpen()) {
        focusFirst(getFocusableElements(current), false);
        use_event_listener_default(current, "keydown", (e) => {
          if (!props.disabled) {
            switch (e.key) {
              case "Tab": {
                e.preventDefault();
                lockFocus(current, e.shiftKey, false);
                break;
              }
              case "Escape": {
                state.close();
                break;
              }
              default:
                break;
            }
          }
        });
      }
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps31(
      omitProps30(props, ["as", "children", "ref"]),
      COMMAND_BAR_PANEL_TAG,
      {
        id: context.panelID,
        ref: setInternalRef,
        get children() {
          return createComponent32(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/command-bar/CommandBarTitle.ts
import { createComponent as createComponent33, mergeProps as mergeProps32 } from "solid-js";
import { omitProps as omitProps31 } from "solid-use/props";
function CommandBarTitle(props) {
  const context = useCommandBarContext("CommandBarTitle");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "h2",
    mergeProps32(
      omitProps31(props, ["as", "children"]),
      COMMAND_BAR_TITLE_TAG,
      {
        id: context.titleID,
        get children() {
          return createComponent33(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/context-menu/ContextMenu.ts
import {
  createComponent as createComponent34,
  createEffect as createEffect21,
  createUniqueId as createUniqueId13,
  mergeProps as mergeProps33
} from "solid-js";
import { omitProps as omitProps32 } from "solid-use/props";

// src/components/context-menu/ContextMenuContext.ts
import { createContext as createContext15, useContext as useContext15 } from "solid-js";
var ContextMenuContext = createContext15();
function useContextMenuContext(componentName) {
  const context = useContext15(ContextMenuContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <ContextMenu>`)
  );
  return context;
}

// src/components/context-menu/tags.ts
var CONTEXT_MENU_TAG = createTag("context-menu");
var CONTEXT_MENU_BOUNDARY_TAG = createTag("context-menu-boundary");
var CONTEXT_MENU_OVERLAY_TAG = createTag("context-menu-overlay");
var CONTEXT_MENU_PANEL_TAG = createTag("context-menu-panel");

// src/components/context-menu/ContextMenu.ts
function isContextMenuUncontrolled(props) {
  return "defaultOpen" in props;
}
function ContextMenu(props) {
  const ownerID = createUniqueId13();
  const boundaryID = createUniqueId13();
  const panelID = createUniqueId13();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  createEffect21(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  return createComponent34(ContextMenuContext.Provider, {
    value: {
      ownerID,
      boundaryID,
      panelID
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps33(
          isContextMenuUncontrolled(props) ? omitProps32(props, [
            "as",
            "children",
            "defaultOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]) : omitProps32(props, [
            "as",
            "children",
            "isOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]),
          CONTEXT_MENU_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createExpandedState(() => state.isOpen()),
          {
            get children() {
              return createComponent34(DisclosureStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/context-menu/ContextMenuBoundary.ts
import { createComponent as createComponent35, createEffect as createEffect22, mergeProps as mergeProps34 } from "solid-js";
import { omitProps as omitProps33 } from "solid-use/props";
function ContextMenuBoundary(props) {
  const context = useContextMenuContext("ContextMenuBoundary");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect22(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      use_event_listener_default(current, "contextmenu", (e) => {
        if (!state.disabled()) {
          e.preventDefault();
          state.open();
        }
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps34(
      omitProps33(props, ["as", "children", "ref"]),
      CONTEXT_MENU_BOUNDARY_TAG,
      {
        id: context.boundaryID,
        ref: setInternalRef,
        get "aria-controls"() {
          return state.isOpen() && context.panelID;
        }
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen()),
      createARIAExpandedState(() => state.isOpen()),
      {
        get children() {
          return createComponent35(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/context-menu/ContextMenuOverlay.ts
import { createComponent as createComponent36, createEffect as createEffect23, mergeProps as mergeProps35 } from "solid-js";
import { omitProps as omitProps34 } from "solid-use/props";
function ContextMenuOverlay(props) {
  useContextMenuContext("ContextMenuOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect23(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps35(
      omitProps34(props, ["as", "children", "ref"]),
      CONTEXT_MENU_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return createComponent36(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/context-menu/ContextMenuPanel.ts
import { createComponent as createComponent37, createEffect as createEffect24, mergeProps as mergeProps36 } from "solid-js";
import { omitProps as omitProps35 } from "solid-use/props";
function ContextMenuPanel(props) {
  const context = useContextMenuContext("ContextMenuPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect24(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      if (state.isOpen()) {
        focusFirst(getFocusableElements(current), false);
        use_event_listener_default(current, "keydown", (e) => {
          if (!props.disabled) {
            switch (e.key) {
              case "Tab": {
                e.preventDefault();
                lockFocus(current, e.shiftKey, false);
                break;
              }
              case "Escape": {
                state.close();
                break;
              }
              default:
                break;
            }
          }
        });
        use_event_listener_default(document, "click", (e) => {
          if (!current.contains(e.target)) {
            state.close();
          }
        });
      }
    }
  });
  return createUnmountable(
    props,
    () => state.isOpen(),
    () => createDynamic(
      () => props.as || "div",
      mergeProps36(
        omitProps35(props, ["as", "unmount", "children", "ref"]),
        CONTEXT_MENU_PANEL_TAG,
        {
          id: context.panelID,
          ref: setInternalRef,
          get children() {
            return createComponent37(DisclosureStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        },
        createDisabledState(() => state.disabled()),
        createExpandedState(() => state.isOpen())
      )
    )
  );
}

// src/components/dialog/Dialog.ts
import {
  createComponent as createComponent38,
  createEffect as createEffect25,
  createUniqueId as createUniqueId14,
  mergeProps as mergeProps37
} from "solid-js";
import { omitProps as omitProps36 } from "solid-use/props";

// src/components/dialog/DialogContext.ts
import { createContext as createContext16, useContext as useContext16 } from "solid-js";
var DialogContext = createContext16();
function useDialogContext(componentName) {
  const context = useContext16(DialogContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Dialog>`)
  );
  return context;
}

// src/components/dialog/tags.ts
var DIALOG_TAG = createTag("dialog");
var DIALOG_DESCRIPTION_TAG = createTag("dialog-description");
var DIALOG_OVERLAY_TAG = createTag("dialog-overlay");
var DIALOG_PANEL_TAG = createTag("dialog-panel");
var DIALOG_TITLE_TAG = createTag("dialog-title");

// src/components/dialog/Dialog.ts
function isDialogUncontrolled(props) {
  return "defaultOpen" in props;
}
function Dialog(props) {
  const ownerID = createUniqueId14();
  const panelID = createUniqueId14();
  const titleID = createUniqueId14();
  const descriptionID = createUniqueId14();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  createEffect25(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  return createComponent38(DialogContext.Provider, {
    value: {
      ownerID,
      panelID,
      titleID,
      descriptionID
    },
    get children() {
      return createUnmountable(
        props,
        () => state.isOpen(),
        () => createDynamic(
          () => props.as || "div",
          mergeProps37(
            isDialogUncontrolled(props) ? omitProps36(props, [
              "as",
              "children",
              "defaultOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]) : omitProps36(props, [
              "as",
              "children",
              "isOpen",
              "disabled",
              "onChange",
              "onClose",
              "onOpen",
              "unmount"
            ]),
            DIALOG_TAG,
            {
              id: ownerID,
              role: "dialog",
              "aria-modal": true,
              "aria-labelledby": titleID,
              "aria-describedby": descriptionID,
              get children() {
                return createComponent38(DisclosureStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createExpandedState(() => state.isOpen())
          )
        )
      );
    }
  });
}

// src/components/dialog/DialogDescription.ts
import { createComponent as createComponent39, mergeProps as mergeProps38 } from "solid-js";
import { omitProps as omitProps37 } from "solid-use/props";
function DialogDescription(props) {
  const context = useDialogContext("DialogDescription");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "p",
    mergeProps38(
      omitProps37(props, ["as", "children"]),
      DIALOG_DESCRIPTION_TAG,
      {
        id: context.descriptionID,
        get children() {
          return createComponent39(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/dialog/DialogOverlay.ts
import { createComponent as createComponent40, createEffect as createEffect26, mergeProps as mergeProps39 } from "solid-js";
import { omitProps as omitProps38 } from "solid-use/props";
function DialogOverlay(props) {
  useDialogContext("DialogOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect26(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps39(
      omitProps38(props, ["as", "children", "ref"]),
      DIALOG_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return createComponent40(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/dialog/DialogPanel.ts
import { createComponent as createComponent41, createEffect as createEffect27, mergeProps as mergeProps40 } from "solid-js";
import { omitProps as omitProps39 } from "solid-use/props";
function DialogPanel(props) {
  const context = useDialogContext("DialogPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect27(() => {
    const current = internalRef();
    if (current instanceof HTMLElement && state.isOpen()) {
      focusFirst(getFocusableElements(current), false);
      use_event_listener_default(current, "keydown", (e) => {
        if (!props.disabled) {
          switch (e.key) {
            case "Tab": {
              e.preventDefault();
              lockFocus(current, e.shiftKey, false);
              break;
            }
            case "Escape": {
              state.close();
              break;
            }
            default:
              break;
          }
        }
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps40(
      omitProps39(props, ["as", "children", "ref"]),
      DIALOG_PANEL_TAG,
      {
        id: context.panelID,
        ref: setInternalRef,
        get children() {
          return createComponent41(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/dialog/DialogTitle.ts
import { createComponent as createComponent42, mergeProps as mergeProps41 } from "solid-js";
import { omitProps as omitProps40 } from "solid-use/props";
function DialogTitle(props) {
  const context = useDialogContext("DialogTitle");
  const state = useDisclosureState();
  return createDynamic(
    () => props.as || "h2",
    mergeProps41(
      omitProps40(props, ["as", "children"]),
      DIALOG_TITLE_TAG,
      {
        id: context.titleID,
        get children() {
          return createComponent42(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/disclosure/Disclosure.ts
import { createComponent as createComponent43, createUniqueId as createUniqueId15, mergeProps as mergeProps42 } from "solid-js";
import { omitProps as omitProps41 } from "solid-use/props";

// src/components/disclosure/DisclosureContext.ts
import { createContext as createContext17, useContext as useContext17 } from "solid-js";
var DisclosureContext = createContext17();
function useDisclosureContext(componentName) {
  const context = useContext17(DisclosureContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Disclosure>`)
  );
  return context;
}

// src/components/disclosure/tags.ts
var DISCLOSURE_TAG = createTag("disclosure");
var DISCLOSURE_BUTTON_TAG = createTag("disclosure-button");
var DISCLOSURE_PANEL_TAG = createTag("disclosure-panel");

// src/components/disclosure/Disclosure.ts
function isDisclosureUncontrolled(props) {
  return "defaultOpen" in props;
}
function Disclosure(props) {
  const ownerID = createUniqueId15();
  const buttonID = createUniqueId15();
  const panelID = createUniqueId15();
  const state = createDisclosureState(props);
  return createComponent43(DisclosureContext.Provider, {
    value: {
      ownerID,
      buttonID,
      panelID
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps42(
          isDisclosureUncontrolled(props) ? omitProps41(props, [
            "as",
            "children",
            "defaultOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]) : omitProps41(props, [
            "as",
            "children",
            "isOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]),
          DISCLOSURE_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createExpandedState(() => state.isOpen()),
          {
            get children() {
              return createComponent43(DisclosureStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/disclosure/DisclosureButton.ts
import { createEffect as createEffect28, mergeProps as mergeProps43 } from "solid-js";
import { createComponent as createComponent44 } from "solid-js/web";
import { omitProps as omitProps42 } from "solid-use/props";
function DisclosureButton(props) {
  const context = useDisclosureContext("DisclosureButton");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => state.disabled() || props.disabled;
  createEffect28(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          state.toggle();
        }
      });
    }
  });
  return createComponent44(
    Button,
    mergeProps43(
      omitProps42(props, ["children", "ref"]),
      DISCLOSURE_BUTTON_TAG,
      {
        id: context.buttonID,
        ref: setInternalRef,
        get "aria-controls"() {
          return state.isOpen() && context.panelID;
        }
      },
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createExpandedState(() => state.isOpen()),
      createARIAExpandedState(() => state.isOpen()),
      {
        get children() {
          return createComponent44(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/disclosure/DisclosurePanel.ts
import { createComponent as createComponent45, mergeProps as mergeProps44 } from "solid-js";
import { omitProps as omitProps43 } from "solid-use/props";
function DisclosurePanel(props) {
  const context = useDisclosureContext("DisclosurePanel");
  const state = useDisclosureState();
  return createUnmountable(
    props,
    () => state.isOpen(),
    () => createDynamic(
      () => props.as || "div",
      mergeProps44(
        omitProps43(props, ["as", "unmount", "children"]),
        DISCLOSURE_PANEL_TAG,
        {
          id: context.panelID,
          get children() {
            return createComponent45(DisclosureStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        },
        createDisabledState(() => state.disabled()),
        createExpandedState(() => state.isOpen())
      )
    )
  );
}

// src/components/feed/Feed.ts
import { createComponent as createComponent46, createUniqueId as createUniqueId16, mergeProps as mergeProps45 } from "solid-js";
import { omitProps as omitProps44 } from "solid-use/props";

// src/components/feed/FeedContext.ts
import { createContext as createContext18, useContext as useContext18 } from "solid-js";
var FeedContext = createContext18();
function useFeedContext(componentName) {
  const context = useContext18(FeedContext);
  assert(context, new Error(`<${componentName}> must be used inside a <Feed>`));
  return context;
}

// src/components/feed/tags.ts
var FEED_TAG = createTag("feed");
var FEED_ARTICLE_TAG = createTag("feed-article");
var FEED_ARTICLE_DESCRIPTION_TAG = createTag(
  "feed-article-description"
);
var FEED_ARTICLE_LABEL_TAG = createTag("feed-article-label");
var FEED_CONTENT_TAG = createTag("feed-content");
var FEED_LABEL_TAG = createTag("feed-label");

// src/components/feed/Feed.ts
function Feed(props) {
  const ownerID = createUniqueId16();
  const labelID = createUniqueId16();
  const contentID = createUniqueId16();
  const [ref, setRef] = createForwardRef(props);
  return createComponent46(FeedContext.Provider, {
    value: {
      ownerID,
      labelID,
      contentID,
      get size() {
        return props.size;
      },
      get busy() {
        return !!props.busy;
      },
      focusNext() {
        const current = ref();
        if (current instanceof HTMLElement) {
          focusNext(
            getFocusableElements(document.documentElement),
            current,
            false,
            false
          );
        }
      },
      focusPrev() {
        const current = ref();
        if (current instanceof HTMLElement) {
          focusPrev(
            getFocusableElements(document.documentElement),
            current,
            false,
            false
          );
        }
      }
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps45(omitProps44(props, ["as", "busy", "size"]), FEED_TAG, {
          id: ownerID,
          ref: setRef
        })
      );
    }
  });
}

// src/components/feed/FeedArticle.ts
import { createComponent as createComponent47, createUniqueId as createUniqueId17, mergeProps as mergeProps46 } from "solid-js";
import { omitProps as omitProps45 } from "solid-use/props";

// src/components/feed/FeedArticleContext.ts
import { createContext as createContext19, useContext as useContext19 } from "solid-js";
var FeedArticleContext = createContext19();
function useFeedArticleContext(componentName) {
  const context = useContext19(FeedArticleContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <FeedArticle>`)
  );
  return context;
}

// src/components/feed/FeedArticle.ts
function FeedArticle(props) {
  const rootContext = useFeedContext("FeedArticle");
  const ownerID = createUniqueId17();
  const labelID = createUniqueId17();
  const descriptionID = createUniqueId17();
  return createComponent47(FeedArticleContext.Provider, {
    value: {
      ownerID,
      labelID,
      descriptionID
    },
    get children() {
      return createDynamic(
        () => props.as || "article",
        mergeProps46(
          omitProps45(props, ["as"]),
          FEED_ARTICLE_TAG,
          createOwnerAttribute(rootContext.ownerID),
          {
            id: ownerID,
            "aria-labelledby": labelID,
            "aria-describedby": descriptionID,
            tabindex: 0,
            get "aria-posinset"() {
              return props.index + 1;
            },
            get "aria-setsize"() {
              return rootContext.size;
            }
          }
        )
      );
    }
  });
}

// src/components/feed/FeedArticleDescription.ts
import { mergeProps as mergeProps47 } from "solid-js";
import { omitProps as omitProps46 } from "solid-use/props";
function FeedArticleDescription(props) {
  const context = useFeedArticleContext("FeedArticleDescription");
  return createDynamic(
    () => props.as || "p",
    mergeProps47(omitProps46(props, ["as"]), FEED_ARTICLE_DESCRIPTION_TAG, {
      id: context.descriptionID
    })
  );
}

// src/components/feed/FeedArticleLabel.ts
import { mergeProps as mergeProps48 } from "solid-js";
import { omitProps as omitProps47 } from "solid-use/props";
function FeedArticleLabel(props) {
  const context = useFeedArticleContext("FeedArticleLabel");
  return createDynamic(
    () => props.as || "span",
    mergeProps48(omitProps47(props, ["as"]), FEED_ARTICLE_LABEL_TAG, {
      id: context.labelID
    })
  );
}

// src/components/feed/FeedContent.ts
import { createComponent as createComponent48, createEffect as createEffect29, mergeProps as mergeProps49, onCleanup as onCleanup8 } from "solid-js";
import { omitProps as omitProps48 } from "solid-use/props";

// src/components/feed/FeedContentContext.ts
import { createContext as createContext20, useContext as useContext20 } from "solid-js";
var FeedContentContext = createContext20();
function createFeedArticleFocusNavigator(owner) {
  return new FocusNavigator(owner);
}

// src/components/feed/FeedContent.ts
function FeedContent(props) {
  const context = useFeedContext("FeedContent");
  const controller = createFeedArticleFocusNavigator(context.ownerID);
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect29(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      controller.setRef(current);
      onCleanup8(() => {
        controller.clearRef();
      });
      use_event_listener_default(current, "keydown", (e) => {
        if (e.ctrlKey) {
          switch (e.key) {
            case "Home": {
              e.preventDefault();
              context.focusPrev();
              break;
            }
            case "End": {
              e.preventDefault();
              context.focusNext();
              break;
            }
            default:
              break;
          }
        }
        switch (e.key) {
          case "PageUp": {
            e.preventDefault();
            controller.setPrevChecked(false);
            break;
          }
          case "PageDown": {
            e.preventDefault();
            controller.setNextChecked(false);
            break;
          }
          default:
            break;
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          controller.setCurrent(e.target);
        }
      });
    }
  });
  return createComponent48(FeedContentContext.Provider, {
    value: controller,
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps49(omitProps48(props, ["as"]), FEED_CONTENT_TAG, {
          id: context.contentID,
          role: "feed",
          "aria-labelledby": context.labelID,
          get "aria-busy"() {
            return context.busy;
          },
          ref: setInternalRef
        })
      );
    }
  });
}

// src/components/feed/FeedLabel.ts
import { mergeProps as mergeProps50 } from "solid-js";
import { omitProps as omitProps49 } from "solid-use/props";
function FeedLabel(props) {
  const context = useFeedContext("FeedLabel");
  return createDynamic(
    () => props.as || "span",
    mergeProps50(omitProps49(props, ["as"]), FEED_LABEL_TAG, {
      id: context.labelID
    })
  );
}

// src/components/listbox/Listbox.ts
import {
  createComponent as createComponent49,
  createEffect as createEffect30,
  createMemo as createMemo12,
  createUniqueId as createUniqueId18,
  mergeProps as mergeProps51
} from "solid-js";
import { omitProps as omitProps50 } from "solid-use/props";

// src/components/listbox/ListboxContext.ts
import { createContext as createContext21, useContext as useContext21 } from "solid-js";
var ListboxContext = createContext21();
function useListboxContext(componentName) {
  const context = useContext21(ListboxContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Listbox>`)
  );
  return context;
}

// src/components/listbox/tags.ts
var LISTBOX_TAG = createTag("listbox");
var LISTBOX_BUTTON_TAG = createTag("listbox-button");
var LISTBOX_LABEL_TAG = createTag("listbox-label");
var LISTBOX_OPTIONS_TAG = createTag("listbox-options");
var LISTBOX_OPTION_TAG = createTag("listbox-option");

// src/components/listbox/Listbox.ts
function isListboxMultiple(props) {
  return !!props.multiple;
}
function isListboxSelectUncontrolled(props) {
  return "defaultValue" in props;
}
function isListboxDisclosureUncontrolled(props) {
  return "defaultOpen" in props;
}
function getProps2(props) {
  if (isListboxSelectUncontrolled(props)) {
    if (isListboxDisclosureUncontrolled(props)) {
      return omitProps50(props, [
        "as",
        "by",
        "children",
        "defaultOpen",
        "defaultValue",
        "disabled",
        "horizontal",
        "multiple",
        "onClose",
        "onDisclosureChange",
        "onOpen",
        "onSelectChange",
        "toggleable"
      ]);
    }
    return omitProps50(props, [
      "as",
      "by",
      "children",
      "isOpen",
      "defaultValue",
      "disabled",
      "horizontal",
      "multiple",
      "onClose",
      "onDisclosureChange",
      "onOpen",
      "onSelectChange",
      "toggleable"
    ]);
  }
  if (isListboxDisclosureUncontrolled(props)) {
    return omitProps50(props, [
      "as",
      "by",
      "children",
      "defaultOpen",
      "value",
      "disabled",
      "horizontal",
      "multiple",
      "onClose",
      "onDisclosureChange",
      "onOpen",
      "onSelectChange",
      "toggleable"
    ]);
  }
  return omitProps50(props, [
    "as",
    "by",
    "children",
    "isOpen",
    "value",
    "disabled",
    "horizontal",
    "multiple",
    "onClose",
    "onDisclosureChange",
    "onOpen",
    "onSelectChange",
    "toggleable"
  ]);
}
function Listbox(props) {
  return createMemo12(() => {
    const ownerID = createUniqueId18();
    const labelID = createUniqueId18();
    const buttonID = createUniqueId18();
    const optionsID = createUniqueId18();
    const disclosureState = createDisclosureState(
      mergeProps51(props, {
        onChange(value) {
          if (props.onDisclosureChange) {
            props.onDisclosureChange(value);
          }
        }
      })
    );
    const selectState = isListboxMultiple(props) ? createMultipleSelectState(
      mergeProps51(props, {
        onChange(value) {
          if (props.onSelectChange) {
            props.onSelectChange(value);
          }
        }
      })
    ) : createSingleSelectState(
      mergeProps51(props, {
        onChange(value) {
          if (props.onSelectChange) {
            props.onSelectChange(value);
          }
        }
      })
    );
    const fsp = useFocusStartPoint();
    createEffect30(() => {
      if (disclosureState.isOpen()) {
        fsp.save();
      } else {
        fsp.load();
      }
    });
    return createComponent49(ListboxContext.Provider, {
      value: {
        get multiple() {
          return props.multiple;
        },
        ownerID,
        labelID,
        buttonID,
        optionsID,
        get horizontal() {
          return props.horizontal;
        },
        buttonHovering: false,
        optionsHovering: false
      },
      get children() {
        return createComponent49(SelectStateProvider, {
          state: selectState,
          get children() {
            return createComponent49(DisclosureStateProvider, {
              state: disclosureState,
              get children() {
                return createDynamic(
                  () => props.as || "div",
                  mergeProps51(
                    getProps2(props),
                    LISTBOX_TAG,
                    {
                      id: ownerID,
                      "aria-labelledby": labelID
                    },
                    createDisabledState(() => selectState.disabled()),
                    createARIADisabledState(() => selectState.disabled()),
                    createHasSelectedState(() => selectState.hasSelected()),
                    createHasActiveState(() => selectState.hasActive()),
                    createExpandedState(() => disclosureState.isOpen()),
                    {
                      get children() {
                        return props.children;
                      }
                    }
                  )
                );
              }
            });
          }
        });
      }
    });
  });
}

// src/components/listbox/ListboxButton.ts
import { createComponent as createComponent50, createEffect as createEffect31, mergeProps as mergeProps52 } from "solid-js";
import { omitProps as omitProps51 } from "solid-use/props";
function ListboxButton(props) {
  const context = useListboxContext("ListboxButton");
  const disclosureState = useDisclosureState();
  const selectState = useSelectState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => disclosureState.disabled() || props.disabled;
  createEffect31(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          disclosureState.toggle();
        }
      });
      use_event_listener_default(current, "keydown", (e) => {
        if (!isDisabled()) {
          switch (e.key) {
            case "ArrowUp":
            case "ArrowDown": {
              e.preventDefault();
              disclosureState.toggle();
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.buttonHovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.buttonHovering = false;
      });
    }
  });
  return createComponent50(
    Button,
    mergeProps52(
      omitProps51(props, ["children", "ref"]),
      LISTBOX_BUTTON_TAG,
      {
        id: context.buttonID,
        "aria-haspopup": "listbox",
        "aria-controls": context.optionsID,
        ref: setInternalRef
      },
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createExpandedState(() => disclosureState.isOpen()),
      createARIAExpandedState(() => disclosureState.isOpen()),
      createHasSelectedState(() => selectState.hasSelected()),
      createHasActiveState(() => selectState.hasActive()),
      {
        get children() {
          return createComponent50(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/listbox/ListboxLabel.ts
import { createComponent as createComponent51, mergeProps as mergeProps53 } from "solid-js";
import { omitProps as omitProps52 } from "solid-use/props";
function ListboxLabel(props) {
  const context = useListboxContext("ListboxLabel");
  const disclosureState = useDisclosureState();
  const selectState = useSelectState();
  return createDynamic(
    () => props.as || "label",
    mergeProps53(
      omitProps52(props, ["as", "children"]),
      LISTBOX_LABEL_TAG,
      {
        id: context.labelID,
        get children() {
          return createComponent51(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => disclosureState.disabled()),
      createExpandedState(() => disclosureState.isOpen()),
      createHasSelectedState(() => selectState.hasSelected()),
      createHasActiveState(() => selectState.hasActive())
    )
  );
}

// src/components/listbox/ListboxOption.ts
import { createComponent as createComponent52, createRenderEffect as createRenderEffect2, mergeProps as mergeProps54 } from "solid-js";
import { omitProps as omitProps53 } from "solid-use/props";

// src/components/listbox/ListboxOptionsContext.ts
import { createContext as createContext22, useContext as useContext22 } from "solid-js";
var ListboxOptionsContext = createContext22();
function useListboxOptionsContext(componentName) {
  const context = useContext22(ListboxOptionsContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <ListboxOptions>`)
  );
  return context;
}
function createListboxOptionsFocusNavigator(owner) {
  return new FocusNavigator(owner);
}

// src/components/listbox/ListboxOption.ts
function ListboxOption(props) {
  const rootContext = useListboxContext("ListboxOptions");
  const context = useListboxOptionsContext("ListboxOptions");
  const disclosure = useDisclosureState();
  const state = createSelectOptionState(props);
  const [internalRef, setInternalRef] = createForwardRef(props);
  createRenderEffect2(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        if (!state.disabled()) {
          state.select();
          if (!rootContext.multiple) {
            disclosure.close();
          }
        }
      });
      use_event_listener_default(current, "focus", () => {
        state.focus();
      });
      use_event_listener_default(current, "blur", () => {
        state.blur();
      });
      use_event_listener_default(current, "mouseenter", () => {
        if (!state.disabled()) {
          current.focus();
        }
      });
      use_event_listener_default(current, "mouseleave", () => {
        if (!state.disabled()) {
          state.blur();
        }
      });
    }
  });
  return createComponent52(
    Button,
    mergeProps54(
      omitProps53(props, ["as", "children", "disabled", "value", "ref"]),
      LISTBOX_OPTION_TAG,
      createOwnerAttribute(context.getId()),
      {
        get as() {
          return props.as || "li";
        },
        role: "option",
        tabindex: -1,
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      {
        get children() {
          return createComponent52(SelectOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/listbox/ListboxOptions.ts
import {
  createComponent as createComponent53,
  createEffect as createEffect32,
  mergeProps as mergeProps55,
  onCleanup as onCleanup10,
  onMount as onMount2,
  untrack as untrack9
} from "solid-js";
import { omitProps as omitProps54 } from "solid-use/props";

// src/utils/create-type-ahead.ts
import { onCleanup as onCleanup9 } from "solid-js";
var TYPE_AHEAD_DEBOUNCE_TIMEOUT = 250;
function createTypeAhead(callback, time = TYPE_AHEAD_DEBOUNCE_TIMEOUT) {
  let characters = "";
  let timeout;
  onCleanup9(() => {
    if (timeout) {
      clearTimeout(timeout);
    }
  });
  return (value) => {
    characters += value;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      callback(characters);
      characters = "";
    }, time);
  };
}

// src/components/listbox/ListboxOptions.ts
function ListboxOptions(props) {
  const context = useListboxContext("ListboxOptions");
  const selectState = useSelectState();
  const disclosureState = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const controller = createListboxOptionsFocusNavigator(context.optionsID);
  const pushCharacter = createTypeAhead((value) => {
    controller.setFirstMatch(value);
  });
  onMount2(() => {
    createEffect32(() => {
      const current = internalRef();
      if (current instanceof HTMLElement && disclosureState.isOpen()) {
        controller.setRef(current);
        onCleanup10(() => {
          controller.clearRef();
        });
        if (untrack9(() => selectState.hasSelected())) {
          controller.setFirstChecked(SELECTED_NODE);
        } else {
          controller.setFirstChecked();
        }
        use_event_listener_default(current, "keydown", (e) => {
          if (!selectState.disabled()) {
            switch (e.key) {
              case "Escape": {
                disclosureState.close();
                break;
              }
              case "ArrowLeft": {
                if (context.horizontal) {
                  e.preventDefault();
                  controller.setPrevChecked(true);
                }
                break;
              }
              case "ArrowUp": {
                if (!context.horizontal) {
                  e.preventDefault();
                  controller.setPrevChecked(true);
                }
                break;
              }
              case "ArrowRight": {
                if (context.horizontal) {
                  e.preventDefault();
                  controller.setNextChecked(true);
                }
                break;
              }
              case "ArrowDown": {
                if (!context.horizontal) {
                  e.preventDefault();
                  controller.setNextChecked(true);
                }
                break;
              }
              case "Home": {
                e.preventDefault();
                controller.setFirstChecked();
                break;
              }
              case "End": {
                e.preventDefault();
                controller.setLastChecked();
                break;
              }
              case " ":
              case "Enter": {
                e.preventDefault();
                break;
              }
              default: {
                if (e.key.length === 1) {
                  pushCharacter(e.key);
                }
                break;
              }
            }
          }
        });
        use_event_listener_default(current, "focusout", (e) => {
          if (context.buttonHovering || context.optionsHovering) {
            return;
          }
          if (!(e.relatedTarget && current.contains(e.relatedTarget))) {
            disclosureState.close();
          }
        });
        use_event_listener_default(current, "focusin", (e) => {
          if (e.target && e.target !== current) {
            controller.setCurrent(e.target);
          }
        });
        use_event_listener_default(current, "mouseenter", () => {
          context.optionsHovering = true;
        });
        use_event_listener_default(current, "mouseleave", () => {
          context.optionsHovering = false;
        });
      }
    });
  });
  return createUnmountable(
    props,
    () => disclosureState.isOpen(),
    () => createComponent53(ListboxOptionsContext.Provider, {
      value: controller,
      get children() {
        return createDynamic(
          () => props.as || "ul",
          mergeProps55(
            omitProps54(props, ["as", "children", "ref"]),
            LISTBOX_OPTIONS_TAG,
            {
              id: context.optionsID,
              role: "listbox",
              "aria-multiselectable": context.multiple,
              "aria-labelledby": context.buttonID,
              ref: setInternalRef,
              get "aria-orientation"() {
                return context.horizontal ? "horizontal" : "vertical";
              },
              get tabindex() {
                return selectState.disabled() ? -1 : 0;
              }
            },
            createDisabledState(() => selectState.disabled()),
            createARIADisabledState(() => selectState.disabled()),
            createExpandedState(() => disclosureState.isOpen()),
            createHasSelectedState(() => selectState.hasSelected()),
            createHasActiveState(() => selectState.hasActive()),
            {
              get children() {
                return createComponent53(SelectStateProvider, {
                  state: selectState,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    })
  );
}

// src/components/menu/Menu.ts
import { createComponent as createComponent54, createEffect as createEffect33, mergeProps as mergeProps56, onCleanup as onCleanup11 } from "solid-js";
import { omitProps as omitProps55 } from "solid-use/props";

// src/components/menu/MenuContext.ts
import { createContext as createContext23, createUniqueId as createUniqueId19, useContext as useContext23 } from "solid-js";
var MenuContext = createContext23();
function useMenuContext(componentName) {
  const context = useContext23(MenuContext);
  assert(context, new Error(`<${componentName}> must be used inside a <Menu>`));
  return context;
}
function createMenuItemFocusNavigator() {
  return new FocusNavigator(createUniqueId19());
}

// src/components/menu/tags.ts
var MENU_TAG = createTag("menu");
var MENU_ITEM_TAG = createTag("menu-item");

// src/components/menu/Menu.ts
function Menu(props) {
  const controller = createMenuItemFocusNavigator();
  const [ref, setRef] = createForwardRef(props);
  const pushCharacter = createTypeAhead((value) => {
    controller.setFirstMatch(value);
  });
  createEffect33(() => {
    const current = ref();
    if (current instanceof HTMLElement) {
      controller.setRef(current);
      onCleanup11(() => {
        controller.clearRef();
      });
      use_event_listener_default(current, "keydown", (e) => {
        switch (e.key) {
          case "ArrowUp":
          case "ArrowLeft": {
            e.preventDefault();
            controller.setPrevChecked(true);
            break;
          }
          case "ArrowDown":
          case "ArrowRight": {
            e.preventDefault();
            controller.setNextChecked(true);
            break;
          }
          case "Home": {
            e.preventDefault();
            controller.setFirstChecked();
            break;
          }
          case "End": {
            e.preventDefault();
            controller.setLastChecked();
            break;
          }
          case " ":
          case "Enter": {
            e.preventDefault();
            break;
          }
          default: {
            if (e.key.length === 1) {
              pushCharacter(e.key);
            }
            break;
          }
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          controller.setCurrent(e.target);
        }
      });
    }
  });
  return createComponent54(MenuContext.Provider, {
    value: controller,
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps56(omitProps55(props, ["as", "ref"]), MENU_TAG, {
          id: controller.getId(),
          role: "menu",
          ref: setRef
        })
      );
    }
  });
}

// src/components/menu/MenuChild.ts
import { createMemo as createMemo13 } from "solid-js";
function MenuChild(props) {
  return createMemo13(() => {
    const body = props.children;
    if (typeof body === "function") {
      return body({
        disabled: () => !!props.disabled
      });
    }
    return body;
  });
}

// src/components/menu/MenuItem.ts
import { createComponent as createComponent55, mergeProps as mergeProps57 } from "solid-js";
import { omitProps as omitProps56 } from "solid-use/props";
function MenuItem(props) {
  const context = useMenuContext("MenuItem");
  return createComponent55(
    Button,
    mergeProps57(
      omitProps56(props, ["as", "disabled", "ref", "children"]),
      MENU_ITEM_TAG,
      createOwnerAttribute(context.getId()),
      {
        get as() {
          return props.as || "li";
        },
        role: "menuitem",
        tabindex: -1
      },
      createDisabledState(() => props.disabled),
      createARIADisabledState(() => props.disabled),
      {
        get children() {
          return createComponent55(MenuChild, {
            get disabled() {
              return props.disabled;
            },
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/popover/Popover.ts
import {
  createComponent as createComponent56,
  createEffect as createEffect34,
  createUniqueId as createUniqueId20,
  mergeProps as mergeProps58
} from "solid-js";
import { omitProps as omitProps57 } from "solid-use/props";

// src/components/popover/PopoverContext.ts
import { createContext as createContext24, useContext as useContext24 } from "solid-js";
var PopoverContext = createContext24();
function usePopoverContext(componentName) {
  const context = useContext24(PopoverContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Popover>`)
  );
  return context;
}

// src/components/popover/tags.ts
var POPOVER_TAG = createTag("popover");
var POPOVER_BUTTON_TAG = createTag("popover-button");
var POPOVER_OVERLAY_TAG = createTag("popover-overlay");
var POPOVER_PANEL_TAG = createTag("popover-panel");

// src/components/popover/Popover.ts
function isPopoverUncontrolled(props) {
  return "defaultOpen" in props;
}
function Popover(props) {
  const ownerID = createUniqueId20();
  const buttonID = createUniqueId20();
  const panelID = createUniqueId20();
  const fsp = useFocusStartPoint();
  const state = createDisclosureState(props);
  createEffect34(() => {
    if (state.isOpen()) {
      fsp.save();
    } else {
      fsp.load();
    }
  });
  return createComponent56(PopoverContext.Provider, {
    value: {
      ownerID,
      buttonID,
      panelID,
      hovering: false
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps58(
          isPopoverUncontrolled(props) ? omitProps57(props, [
            "as",
            "children",
            "defaultOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]) : omitProps57(props, [
            "as",
            "children",
            "isOpen",
            "disabled",
            "onChange",
            "onClose",
            "onOpen"
          ]),
          POPOVER_TAG,
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createExpandedState(() => state.isOpen()),
          {
            get children() {
              return createComponent56(DisclosureStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/popover/PopoverButton.ts
import { createComponent as createComponent57, createEffect as createEffect35, mergeProps as mergeProps59 } from "solid-js";
import { omitProps as omitProps58 } from "solid-use/props";
function PopoverButton(props) {
  const context = usePopoverContext("PopoverButton");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isDisabled = () => state.disabled() || props.disabled;
  createEffect35(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      context.anchor = current;
      use_event_listener_default(current, "click", () => {
        if (!isDisabled()) {
          state.toggle();
        }
      });
      use_event_listener_default(current, "mouseenter", () => {
        context.hovering = true;
      });
      use_event_listener_default(current, "mouseleave", () => {
        context.hovering = false;
      });
    }
  });
  return createComponent57(
    Button,
    mergeProps59(
      omitProps58(props, ["children", "ref"]),
      POPOVER_BUTTON_TAG,
      {
        id: context.buttonID,
        ref: setInternalRef,
        get "aria-controls"() {
          return state.isOpen() && context.panelID;
        }
      },
      createDisabledState(isDisabled),
      createARIADisabledState(isDisabled),
      createExpandedState(() => state.isOpen()),
      createARIAExpandedState(() => state.isOpen()),
      {
        get children() {
          return createComponent57(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/popover/PopoverOverlay.ts
import { createComponent as createComponent58, createEffect as createEffect36, mergeProps as mergeProps60 } from "solid-js";
import { omitProps as omitProps59 } from "solid-use/props";
function PopoverOverlay(props) {
  usePopoverContext("PopoverOverlay");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect36(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.close();
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps60(
      omitProps59(props, ["as", "children", "ref"]),
      POPOVER_OVERLAY_TAG,
      {
        ref: setInternalRef,
        get children() {
          return createComponent58(DisclosureStateChild, {
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createExpandedState(() => state.isOpen())
    )
  );
}

// src/components/popover/PopoverPanel.ts
import { createComponent as createComponent59, createEffect as createEffect37, mergeProps as mergeProps61 } from "solid-js";
import { omitProps as omitProps60 } from "solid-use/props";
function PopoverPanel(props) {
  const context = usePopoverContext("PopoverPanel");
  const state = useDisclosureState();
  const [internalRef, setInternalRef] = createForwardRef(props);
  createEffect37(() => {
    const current = internalRef();
    if (current instanceof HTMLElement && state.isOpen()) {
      focusFirst(getFocusableElements(current), false);
      use_event_listener_default(current, "keydown", (e) => {
        if (!state.disabled()) {
          switch (e.key) {
            case "Tab": {
              e.preventDefault();
              lockFocus(current, e.shiftKey, false);
              break;
            }
            case "Escape": {
              state.close();
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "focusout", (e) => {
        if (context.hovering) {
          return;
        }
        if (!(e.relatedTarget && current.contains(e.relatedTarget))) {
          state.close();
        }
      });
    }
  });
  return createUnmountable(
    props,
    () => state.isOpen(),
    () => createDynamic(
      () => props.as || "div",
      mergeProps61(
        omitProps60(props, ["as", "unmount", "children", "ref"]),
        POPOVER_PANEL_TAG,
        {
          id: context.panelID,
          ref: setInternalRef,
          get children() {
            return createComponent59(DisclosureStateChild, {
              get children() {
                return props.children;
              }
            });
          }
        },
        createDisabledState(() => state.disabled()),
        createExpandedState(() => state.isOpen())
      )
    )
  );
}

// src/components/radio-group/RadioGroup.ts
import {
  createComponent as createComponent60,
  createEffect as createEffect38,
  createUniqueId as createUniqueId22,
  mergeProps as mergeProps62,
  onCleanup as onCleanup12
} from "solid-js";
import { omitProps as omitProps61 } from "solid-use/props";

// src/components/radio-group/RadioGroupContext.ts
import { createContext as createContext25, useContext as useContext25 } from "solid-js";
var RadioGroupContext = createContext25();
function useRadioGroupContext(componentName) {
  const context = useContext25(RadioGroupContext);
  assert(
    context,
    new Error(
      `<${componentName}> must be used inside a <RadioGroup> or <RadioGroupOption>`
    )
  );
  return context;
}

// src/components/radio-group/RadioGroupRootContext.ts
import { createContext as createContext26, createUniqueId as createUniqueId21, useContext as useContext26 } from "solid-js";
var RadioGroupRootContext = createContext26();
function useRadioGroupRootContext(componentName) {
  const context = useContext26(RadioGroupRootContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <RadioGroup>`)
  );
  return context;
}
function createRadioGroupOptionFocusNavigator() {
  return new FocusNavigator(createUniqueId21());
}

// src/components/radio-group/tags.ts
var RADIO_GROUP_TAG = createTag("radio-group");
var RADIO_GROUP_DESCRIPTION_TAG = createTag("radio-group-description");
var RADIO_GROUP_LABEL_TAG = createTag("radio-group-label");
var RADIO_GROUP_OPTION_TAG = createTag("radio-group-option");

// src/components/radio-group/RadioGroup.ts
function isRadioGroupUncontrolled(props) {
  return "defaultValue" in props;
}
function RadioGroup(props) {
  const controller = createRadioGroupOptionFocusNavigator();
  const descriptionID = createUniqueId22();
  const labelID = createUniqueId22();
  const state = createSingleSelectState(props);
  const [ref, setRef] = createForwardRef(props);
  createEffect38(() => {
    const current = ref();
    if (current instanceof HTMLElement) {
      controller.setRef(current);
      onCleanup12(() => {
        controller.clearRef();
      });
      use_event_listener_default(current, "keydown", (e) => {
        if (!state.disabled()) {
          switch (e.key) {
            case "ArrowLeft":
            case "ArrowUp": {
              e.preventDefault();
              controller.setPrevChecked(true);
              break;
            }
            case "ArrowRight":
            case "ArrowDown": {
              e.preventDefault();
              controller.setNextChecked(true);
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          controller.setCurrent(e.target);
        }
      });
    }
  });
  return createComponent60(RadioGroupRootContext.Provider, {
    value: controller,
    get children() {
      return createComponent60(RadioGroupContext.Provider, {
        value: {
          descriptionID,
          labelID
        },
        get children() {
          return createDynamic(
            () => props.as || "div",
            mergeProps62(
              isRadioGroupUncontrolled(props) ? omitProps61(props, [
                "as",
                "by",
                "children",
                "defaultValue",
                "disabled",
                "multiple",
                "onChange",
                "ref",
                "toggleable"
              ]) : omitProps61(props, [
                "as",
                "by",
                "children",
                "value",
                "disabled",
                "multiple",
                "onChange",
                "ref",
                "toggleable"
              ]),
              RADIO_GROUP_TAG,
              {
                role: "radiogroup",
                "aria-labelledby": labelID,
                "aria-describedby": descriptionID,
                ref: setRef
              },
              createDisabledState(() => state.disabled()),
              createARIADisabledState(() => state.disabled()),
              createHasActiveState(() => state.hasActive()),
              createHasSelectedState(() => state.hasSelected()),
              {
                get children() {
                  return createComponent60(SelectStateProvider, {
                    state,
                    get children() {
                      return props.children;
                    }
                  });
                }
              }
            )
          );
        }
      });
    }
  });
}

// src/components/radio-group/RadioGroupDescription.ts
import { mergeProps as mergeProps63 } from "solid-js";
import { omitProps as omitProps62 } from "solid-use/props";
function RadioGroupDescription(props) {
  const context = useRadioGroupContext("RadioGroupDescription");
  return createDynamic(
    () => props.as || "div",
    mergeProps63(omitProps62(props, ["as"]), RADIO_GROUP_DESCRIPTION_TAG, {
      id: context.descriptionID
    })
  );
}

// src/components/radio-group/RadioGroupLabel.ts
import { mergeProps as mergeProps64 } from "solid-js";
import { omitProps as omitProps63 } from "solid-use/props";
function RadioGroupLabel(props) {
  const context = useRadioGroupContext("RadioGroupLabel");
  return createDynamic(
    () => props.as || "label",
    mergeProps64(omitProps63(props, ["as"]), RADIO_GROUP_LABEL_TAG, {
      id: context.labelID
    })
  );
}

// src/components/radio-group/RadioGroupOption.ts
import {
  createComponent as createComponent61,
  createEffect as createEffect39,
  createUniqueId as createUniqueId23,
  mergeProps as mergeProps65
} from "solid-js";
import { omitProps as omitProps64 } from "solid-use/props";
function RadioGroupOption(props) {
  const context = useRadioGroupRootContext("RadioGroupOption");
  const descriptionID = createUniqueId23();
  const labelID = createUniqueId23();
  const [internalRef, setInternalRef] = createForwardRef(props);
  const state = createSelectOptionState(props);
  createEffect39(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.select();
      });
      use_event_listener_default(current, "focus", () => {
        state.focus();
        state.select();
      });
      use_event_listener_default(current, "blur", () => {
        state.blur();
      });
    }
  });
  return createComponent61(RadioGroupContext.Provider, {
    value: { descriptionID, labelID },
    get children() {
      return createComponent61(
        Button,
        mergeProps65(
          omitProps64(props, ["as", "children", "value", "disabled", "ref"]),
          RADIO_GROUP_OPTION_TAG,
          createOwnerAttribute(context.getId()),
          {
            get as() {
              return props.as || "div";
            },
            role: "radio",
            "aria-labelledby": labelID,
            "aria-describedby": descriptionID,
            ref: setInternalRef,
            get tabindex() {
              const selected = state.isSelected();
              return state.disabled() || !selected ? -1 : 0;
            }
          },
          createDisabledState(() => state.disabled()),
          createARIADisabledState(() => state.disabled()),
          createCheckedState(() => state.isSelected()),
          createARIACheckedState(() => state.isSelected()),
          createActiveState(() => state.isActive()),
          {
            get children() {
              return createComponent61(SelectOptionStateProvider, {
                state,
                get children() {
                  return props.children;
                }
              });
            }
          }
        )
      );
    }
  });
}

// src/components/select/Select.ts
import {
  createComponent as createComponent62,
  createEffect as createEffect40,
  createMemo as createMemo14,
  mergeProps as mergeProps66,
  onCleanup as onCleanup13
} from "solid-js";
import { omitProps as omitProps65 } from "solid-use/props";

// src/components/select/SelectContext.ts
import { createContext as createContext27, createUniqueId as createUniqueId24, useContext as useContext27 } from "solid-js";
var SelectContext = createContext27();
function useSelectContext(componentName) {
  const context = useContext27(SelectContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Select>`)
  );
  return context;
}
function createSelectOptionFocusNavigator() {
  return new FocusNavigator(createUniqueId24());
}

// src/components/select/tags.ts
var SELECT_TAG = createTag("select");
var SELECT_OPTION_TAG = createTag("select-option");

// src/components/select/Select.ts
function isSelectMultiple(props) {
  return !!props.multiple;
}
function isSelectUncontrolled(props) {
  return "defaultValue" in props;
}
function Select(props) {
  return createMemo14(() => {
    const controller = createSelectOptionFocusNavigator();
    const [ref, setRef] = createForwardRef(props);
    const state = isSelectMultiple(props) ? createMultipleSelectState(props) : createSingleSelectState(props);
    const pushCharacter = createTypeAhead((value) => {
      controller.setFirstMatch(value);
    });
    createEffect40(() => {
      const current = ref();
      if (current instanceof HTMLElement) {
        controller.setRef(current);
        onCleanup13(() => {
          controller.clearRef();
        });
        use_event_listener_default(current, "keydown", (e) => {
          if (!state.disabled()) {
            switch (e.key) {
              case "ArrowUp": {
                if (!props.horizontal) {
                  e.preventDefault();
                  controller.setPrevChecked(true);
                }
                break;
              }
              case "ArrowLeft": {
                if (props.horizontal) {
                  e.preventDefault();
                  controller.setPrevChecked(true);
                }
                break;
              }
              case "ArrowDown": {
                if (!props.horizontal) {
                  e.preventDefault();
                  controller.setNextChecked(true);
                }
                break;
              }
              case "ArrowRight": {
                if (props.horizontal) {
                  e.preventDefault();
                  controller.setNextChecked(true);
                }
                break;
              }
              case "Home": {
                e.preventDefault();
                controller.setFirstChecked();
                break;
              }
              case "End": {
                e.preventDefault();
                controller.setLastChecked();
                break;
              }
              case " ":
              case "Enter": {
                e.preventDefault();
                break;
              }
              default: {
                if (e.key.length === 1) {
                  pushCharacter(e.key);
                }
                break;
              }
            }
          }
        });
        use_event_listener_default(current, "focus", () => {
          if (state.hasSelected()) {
            controller.setFirstChecked(SELECTED_NODE);
          } else {
            controller.setFirstChecked();
          }
        });
        use_event_listener_default(current, "focusin", (e) => {
          if (e.target && e.target !== current) {
            controller.setCurrent(e.target);
          }
        });
      }
    });
    return createComponent62(SelectContext.Provider, {
      value: {
        controller,
        get horizontal() {
          return !!props.horizontal;
        }
      },
      get children() {
        return createDynamic(
          () => props.as || "ul",
          mergeProps66(
            isSelectUncontrolled(props) ? omitProps65(props, [
              "as",
              "by",
              "children",
              "defaultValue",
              "disabled",
              "horizontal",
              "multiple",
              "onChange",
              "ref",
              "toggleable"
            ]) : omitProps65(props, [
              "as",
              "by",
              "children",
              "value",
              "disabled",
              "horizontal",
              "multiple",
              "onChange",
              "ref",
              "toggleable"
            ]),
            SELECT_TAG,
            {
              id: controller.getId(),
              role: "listbox",
              get "aria-multiselectable"() {
                return props.multiple;
              },
              ref: setRef,
              get "aria-orientation"() {
                return props.horizontal ? "horizontal" : "vertical";
              },
              get tabindex() {
                return state.hasActive() ? -1 : 0;
              }
            },
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createHasSelectedState(() => state.hasSelected()),
            createHasActiveState(() => state.hasActive()),
            {
              get children() {
                return createComponent62(SelectStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    });
  });
}

// src/components/select/SelectOption.ts
import { createComponent as createComponent63, createEffect as createEffect41, mergeProps as mergeProps67 } from "solid-js";
import { omitProps as omitProps66 } from "solid-use/props";
function SelectOption(props) {
  const context = useSelectContext("SelectOption");
  const [internalRef, setInternalRef] = createForwardRef(props);
  const state = createSelectOptionState(props);
  createEffect41(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.select();
      });
      use_event_listener_default(current, "focus", () => {
        state.focus();
      });
      use_event_listener_default(current, "blur", () => {
        state.blur();
      });
      use_event_listener_default(current, "mouseenter", () => {
        if (!state.disabled()) {
          current.focus();
        }
      });
      use_event_listener_default(current, "mouseleave", () => {
        if (!state.disabled()) {
          current.blur();
        }
      });
    }
  });
  return createComponent63(
    Button,
    mergeProps67(
      omitProps66(props, ["as", "children", "value", "ref"]),
      SELECT_OPTION_TAG,
      createOwnerAttribute(context.controller.getId()),
      {
        get as() {
          return props.as || "li";
        },
        role: "option",
        get tabindex() {
          return state.isActive() ? 0 : -1;
        },
        ref: setInternalRef
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive()),
      {
        get children() {
          return createComponent63(SelectOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      }
    )
  );
}

// src/components/tabs/Tab.ts
import { createComponent as createComponent64, createEffect as createEffect42, mergeProps as mergeProps68 } from "solid-js";
import { omitProps as omitProps67 } from "solid-use/props";

// src/components/tabs/TabGroupContext.ts
import { createContext as createContext28, useContext as useContext28 } from "solid-js";
var TabGroupContext = createContext28();
function useTabGroupContext(componentName) {
  const context = useContext28(TabGroupContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <TabGroup>`)
  );
  return context;
}

// src/components/tabs/TabListContext.ts
import { createContext as createContext29, createUniqueId as createUniqueId25, useContext as useContext29 } from "solid-js";
var TabListContext = createContext29();
function useTabListContext(componentName) {
  const context = useContext29(TabListContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <TabList>`)
  );
  return context;
}
function createTabFocusNavigator() {
  return new FocusNavigator(createUniqueId25());
}

// src/components/tabs/tags.ts
var TAB_GROUP_TAG = createTag("tab-group");
var TAB_LIST_TAG = createTag("tab-list");
var TAB_TAG = createTag("tab");
var TAB_PANEL_TAG = createTag("tab-panel");

// src/components/tabs/Tab.ts
function Tab(props) {
  const rootContext = useTabGroupContext("Tab");
  const listContext = useTabListContext("Tab");
  const [internalRef, setInternalRef] = createForwardRef(props);
  const state = createSelectOptionState(props);
  createEffect42(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.select();
      });
      use_event_listener_default(current, "focus", () => {
        state.focus();
        state.select();
      });
      use_event_listener_default(current, "blur", () => {
        state.blur();
        state.select();
      });
    }
  });
  return createComponent64(
    Button,
    mergeProps68(
      omitProps67(props, ["as", "children", "value", "disabled", "ref"]),
      TAB_TAG,
      createOwnerAttribute(listContext.getId()),
      {
        get as() {
          return props.as || "div";
        },
        role: "tab",
        ref: setInternalRef,
        get id() {
          return rootContext.getId("tab", props.value);
        },
        get "aria-controls"() {
          return rootContext.getId("tab-panel", props.value);
        },
        get tabindex() {
          const selected = state.isSelected();
          return state.disabled() || !selected ? -1 : 0;
        },
        get children() {
          return createComponent64(SelectOptionStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      },
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled()),
      createSelectedState(() => state.isSelected()),
      createARIASelectedState(() => state.isSelected()),
      createActiveState(() => state.isActive())
    )
  );
}

// src/components/tabs/TabGroup.ts
import {
  createComponent as createComponent65,
  createMemo as createMemo15,
  createUniqueId as createUniqueId26,
  mergeProps as mergeProps69
} from "solid-js";
import { omitProps as omitProps68 } from "solid-use/props";
function isTabGroupUncontrolled(props) {
  return "defaultValue" in props;
}
function TabGroup(props) {
  return createMemo15(() => {
    const ownerID = createUniqueId26();
    const state = createSingleSelectState(props);
    const ids = /* @__PURE__ */ new Map();
    return createComponent65(TabGroupContext.Provider, {
      value: {
        get horizontal() {
          return props.horizontal;
        },
        getId(kind, value) {
          let currentID = ids.get(value);
          if (!currentID) {
            currentID = ids.size;
            ids.set(value, currentID);
          }
          return `${ownerID}__${kind}-${currentID}`;
        }
      },
      get children() {
        return createDynamic(
          () => props.as || "div",
          mergeProps69(
            isTabGroupUncontrolled(props) ? omitProps68(props, [
              "as",
              "children",
              "defaultValue",
              "disabled",
              "onChange",
              "by",
              "ref",
              "toggleable",
              "horizontal"
            ]) : omitProps68(props, [
              "as",
              "children",
              "value",
              "disabled",
              "onChange",
              "by",
              "ref",
              "toggleable",
              "horizontal"
            ]),
            TAB_GROUP_TAG,
            createDisabledState(() => state.disabled()),
            createARIADisabledState(() => state.disabled()),
            createHasSelectedState(() => state.hasSelected()),
            createHasActiveState(() => state.hasActive()),
            {
              get children() {
                return createComponent65(SelectStateProvider, {
                  state,
                  get children() {
                    return props.children;
                  }
                });
              }
            }
          )
        );
      }
    });
  });
}

// src/components/tabs/TabList.ts
import { createComponent as createComponent66, createEffect as createEffect43, mergeProps as mergeProps70, onCleanup as onCleanup14 } from "solid-js";
import { omitProps as omitProps69 } from "solid-use/props";
function TabList(props) {
  const rootContext = useTabGroupContext("TabList");
  const controller = createTabFocusNavigator();
  const state = useSelectState();
  const [ref, setRef] = createForwardRef(props);
  createEffect43(() => {
    const current = ref();
    if (current instanceof HTMLElement) {
      controller.setRef(current);
      onCleanup14(() => {
        controller.clearRef();
      });
      use_event_listener_default(current, "keydown", (e) => {
        if (!state.disabled()) {
          switch (e.key) {
            case "ArrowUp": {
              if (!rootContext.horizontal) {
                e.preventDefault();
                controller.setPrevChecked(true);
              }
              break;
            }
            case "ArrowLeft": {
              if (rootContext.horizontal) {
                e.preventDefault();
                controller.setPrevChecked(true);
              }
              break;
            }
            case "ArrowDown": {
              if (!rootContext.horizontal) {
                e.preventDefault();
                controller.setNextChecked(true);
              }
              break;
            }
            case "ArrowRight": {
              if (rootContext.horizontal) {
                e.preventDefault();
                controller.setNextChecked(true);
              }
              break;
            }
            case "Home": {
              e.preventDefault();
              controller.setFirstChecked();
              break;
            }
            case "End": {
              e.preventDefault();
              controller.setLastChecked();
              break;
            }
          }
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          controller.setCurrent(e.target);
        }
      });
    }
  });
  return createComponent66(TabListContext.Provider, {
    value: controller,
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps70(
          omitProps69(props, ["as", "ref", "children"]),
          TAB_LIST_TAG,
          {
            role: "tablist",
            get "aria-orientation"() {
              return rootContext.horizontal ? "horizontal" : "vertical";
            },
            ref: setRef,
            get children() {
              return createComponent66(SelectStateChild, {
                get children() {
                  return props.children;
                }
              });
            }
          },
          createHasSelectedState(() => state.hasSelected()),
          createHasActiveState(() => state.hasActive())
        )
      );
    }
  });
}

// src/components/tabs/TabPanel.ts
import { createComponent as createComponent67, mergeProps as mergeProps71 } from "solid-js";
import { omitProps as omitProps70 } from "solid-use/props";
function TabPanel(props) {
  const rootContext = useTabGroupContext("TabPanel");
  const state = createSelectOptionState(props);
  return createUnmountable(
    props,
    () => state.isSelected(),
    () => createDynamic(
      () => props.as || "div",
      mergeProps71(
        omitProps70(props, ["as", "disabled", "unmount", "value"]),
        TAB_PANEL_TAG,
        {
          role: "tabpanel",
          get tabindex() {
            return state.isSelected() ? 0 : -1;
          },
          get id() {
            return rootContext.getId("tab-panel", props.value);
          },
          get "aria-labelledby"() {
            return rootContext.getId("tab", props.value);
          },
          get children() {
            return createComponent67(SelectOptionStateProvider, {
              state,
              get children() {
                return props.children;
              }
            });
          }
        },
        createSelectedState(() => state.isSelected()),
        createActiveState(() => state.isActive())
      )
    )
  );
}

// src/components/toast/index.ts
import {
  createComponent as createComponent68,
  createContext as createContext30,
  createEffect as createEffect44,
  createSignal as createSignal10,
  createUniqueId as createUniqueId27,
  mergeProps as mergeProps72,
  onCleanup as onCleanup15,
  useContext as useContext30
} from "solid-js";
import { omitProps as omitProps71 } from "solid-use/props";
var TOAST_TAG = createTag("toast");
var TOASTER_TAG = createTag("toaster");
var ToastContext = createContext30();
function useToastContext(componentName) {
  const context = useContext30(ToastContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Toaster>`)
  );
  return context;
}
function Toast(props) {
  useToastContext("Toast");
  return createDynamic(
    () => props.as || "div",
    mergeProps72(omitProps71(props, ["as"]), TOAST_TAG, {
      role: "status",
      "aria-live": "polite"
    })
  );
}
function Toaster(props) {
  const ownerID = createUniqueId27();
  return createComponent68(ToastContext.Provider, {
    value: {
      ownerID
    },
    get children() {
      return createDynamic(
        () => props.as || "div",
        mergeProps72(omitProps71(props, ["as"]), TOASTER_TAG)
      );
    }
  });
}
var _ToasterStore = class _ToasterStore {
  constructor() {
    this.queue = [];
    this.listeners = /* @__PURE__ */ new Set();
    this.toastID = 0;
    this.id = _ToasterStore.toasterID;
    _ToasterStore.toasterID += 1;
  }
  subscribe(callback) {
    this.listeners.add(callback);
    return () => {
      this.listeners.delete(callback);
    };
  }
  notify() {
    const clone = [...this.queue];
    for (const listener of this.listeners.keys()) {
      listener(clone);
    }
  }
  create(data) {
    const id = `toast-${this.id}-[${this.toastID}`;
    this.toastID += 1;
    this.queue.push({
      id,
      data
    });
    this.notify();
    return id;
  }
  remove(id) {
    this.queue = this.queue.filter((item) => item.id !== id);
    this.notify();
  }
  clear() {
    this.queue = [];
    this.notify();
  }
  getQueue() {
    return this.queue;
  }
};
_ToasterStore.toasterID = 0;
var ToasterStore = _ToasterStore;
function useToaster(toaster) {
  const [signal, setSignal] = createSignal10(toaster.getQueue());
  createEffect44(() => {
    onCleanup15(toaster.subscribe(setSignal));
  });
  return signal;
}

// src/components/toggle/index.ts
import { createComponent as createComponent70, createEffect as createEffect45, mergeProps as mergeProps73 } from "solid-js";
import { omitProps as omitProps72 } from "solid-use/props";

// src/states/create-toggle-state.ts
import {
  createComponent as createComponent69,
  createContext as createContext31,
  createMemo as createMemo16,
  createSignal as createSignal11,
  untrack as untrack10,
  useContext as useContext31
} from "solid-js";
function createToggleState(options) {
  let signal;
  let setSignal;
  if ("defaultPressed" in options) {
    const [isOpen, setIsOpen] = createSignal11(options.defaultPressed);
    signal = isOpen;
    setSignal = (value) => {
      setIsOpen(value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    signal = createMemo16(() => options.pressed);
    setSignal = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  const isDisabled = createMemo16(() => !!options.disabled);
  return {
    pressed() {
      return signal();
    },
    setState(value) {
      if (!untrack10(isDisabled)) {
        setSignal(value);
      }
    },
    disabled: isDisabled,
    check() {
      if (!untrack10(isDisabled)) {
        setSignal(true);
      }
    },
    uncheck() {
      if (!untrack10(isDisabled)) {
        setSignal(false);
      }
    },
    toggle() {
      if (!untrack10(isDisabled)) {
        setSignal(!untrack10(signal));
      }
    }
  };
}
var ToggleStateContext = createContext31();
function ToggleStateProvider(props) {
  return createComponent69(ToggleStateContext.Provider, {
    value: props.state,
    get children() {
      const current = props.children;
      if (typeof current === "function") {
        return current(props.state);
      }
      return current;
    }
  });
}
function useToggleState() {
  const ctx = useContext31(ToggleStateContext);
  assert(ctx, new Error("Missing <ToggleStateProvider>"));
  return ctx;
}
function ToggleStateChild(props) {
  const state = useToggleState();
  return createMemo16(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return createMemo16(() => current(state));
    }
    return current;
  });
}

// src/components/toggle/index.ts
var TOGGLE_TAG = createTag("toggle");
function isToggleUncontrolled(props) {
  return "defaultPressed" in props;
}
function Toggle(props) {
  const [ref, setRef] = createForwardRef(props);
  const state = createToggleState(props);
  createEffect45(() => {
    const current = ref();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "click", () => {
        state.toggle();
      });
    }
  });
  return createComponent70(
    Button,
    mergeProps73(
      isToggleUncontrolled(props) ? omitProps72(props, [
        "onChange",
        "defaultPressed",
        "ref",
        "disabled",
        "children"
      ]) : omitProps72(props, [
        "onChange",
        "pressed",
        "ref",
        "disabled",
        "children"
      ]),
      TOGGLE_TAG,
      {
        ref: setRef,
        get children() {
          return createComponent70(ToggleStateProvider, {
            state,
            get children() {
              return props.children;
            }
          });
        }
      },
      createPressedState(() => state.pressed()),
      createARIAPressedState(() => state.pressed()),
      createDisabledState(() => state.disabled()),
      createARIADisabledState(() => state.disabled())
    )
  );
}

// src/components/toolbar/index.ts
import { createEffect as createEffect46, mergeProps as mergeProps74 } from "solid-js";
import { omitProps as omitProps73 } from "solid-use/props";
var TOOLBAR_TAG = createTag("toolbar");
function Toolbar(props) {
  const [internalRef, setInternalRef] = createForwardRef(props);
  const isHorizontal = () => props.horizontal == null ? true : props.horizontal;
  let focusedElement;
  function getNextFocusable2() {
    const ref = internalRef();
    if (ref instanceof HTMLElement && document.activeElement && ref.contains(document.activeElement)) {
      focusNext(
        getFocusableElements(ref),
        document.activeElement,
        false,
        false
      );
    }
  }
  function getPrevFocusable() {
    const ref = internalRef();
    if (ref instanceof HTMLElement && document.activeElement && ref.contains(document.activeElement)) {
      focusPrev(
        getFocusableElements(ref),
        document.activeElement,
        false,
        false
      );
    }
  }
  createEffect46(() => {
    const current = internalRef();
    if (current instanceof HTMLElement) {
      use_event_listener_default(current, "keydown", (e) => {
        switch (e.key) {
          case "ArrowLeft": {
            if (isHorizontal()) {
              e.preventDefault();
              getPrevFocusable();
            }
            break;
          }
          case "ArrowUp": {
            if (!isHorizontal()) {
              e.preventDefault();
              getPrevFocusable();
            }
            break;
          }
          case "ArrowRight": {
            if (isHorizontal()) {
              e.preventDefault();
              getNextFocusable2();
            }
            break;
          }
          case "ArrowDown": {
            if (!isHorizontal()) {
              e.preventDefault();
              getNextFocusable2();
            }
            break;
          }
          case "Home": {
            if (focusFirst(getFocusableElements(current), false)) {
              e.preventDefault();
            }
            break;
          }
          case "End": {
            if (focusLast(getFocusableElements(current), false)) {
              e.preventDefault();
            }
            break;
          }
        }
      });
      use_event_listener_default(current, "focus", () => {
        if (focusedElement) {
          focusedElement.focus();
        } else {
          focusFirst(getFocusableElements(current), false);
        }
      });
      use_event_listener_default(current, "focusin", (e) => {
        if (e.target && e.target !== current) {
          focusedElement = e.target;
        }
      });
    }
  });
  return createDynamic(
    () => props.as || "div",
    mergeProps74(omitProps73(props, ["as", "horizontal", "ref"]), TOOLBAR_TAG, {
      role: "toolbar",
      tabindex: 0,
      ref: setInternalRef,
      get "aria-orientation"() {
        return isHorizontal() ? "horizontal" : "vertical";
      }
    })
  );
}

// src/components/transition/index.ts
import {
  createComponent as createComponent71,
  createContext as createContext32,
  createEffect as createEffect47,
  createSignal as createSignal12,
  mergeProps as mergeProps75,
  useContext as useContext32
} from "solid-js";
import { omitProps as omitProps74 } from "solid-use/props";
var TransitionRootContext = createContext32();
var TransitionCounterContext = createContext32();
function useTransitionRootContext(componentName) {
  const context = useContext32(TransitionRootContext);
  assert(
    context,
    new Error(`<${componentName}> must be used inside a <Transition>`)
  );
  return context;
}
function createTransitionCounter() {
  const [size, setSize] = createSignal12(0);
  return {
    // Reactive set
    register() {
      setSize((c) => c + 1);
    },
    unregister() {
      setSize((c) => c - 1);
    },
    done() {
      return size() === 0;
    }
  };
}
function getClassList(classes) {
  return classes ? classes.split(" ") : [];
}
function addClassList(ref, classes) {
  const filtered = classes.filter((value) => value);
  if (filtered.length) {
    ref.classList.add(...filtered);
  }
}
function removeClassList(ref, classes) {
  const filtered = classes.filter((value) => value);
  if (filtered.length) {
    ref.classList.remove(...filtered);
  }
}
function TransitionChild(props) {
  const values = useTransitionRootContext("TransitionChild");
  const transitionParent = useContext32(TransitionCounterContext);
  const transitionChildren = createTransitionCounter();
  const [state, setState] = createSignal12();
  const [visible, setVisible] = createSignal12(values.show);
  const [ref, setRef] = createForwardRef(props);
  let initial = true;
  function transition(element, shouldEnter) {
    if (shouldEnter) {
      if (initial) {
        const enter = getClassList(props.enter);
        const enterFrom = getClassList(props.enterFrom);
        const enterTo = getClassList(props.enterTo);
        const entered = getClassList(props.entered);
        const endTransition = () => {
          removeClassList(element, enter);
          removeClassList(element, enterTo);
          setState("entered");
          addClassList(element, entered);
          if (props.afterEnter) {
            props.afterEnter();
          }
        };
        if (props.beforeEnter) {
          props.beforeEnter();
        }
        setState("enter-from");
        addClassList(element, enter);
        addClassList(element, enterFrom);
        requestAnimationFrame(() => {
          removeClassList(element, enterFrom);
          setState("enter-to");
          addClassList(element, enterTo);
          element.addEventListener("transitionend", endTransition, {
            once: true
          });
          element.addEventListener("animationend", endTransition, {
            once: true
          });
        });
      }
    } else {
      const leave = getClassList(props.leave);
      const leaveFrom = getClassList(props.leaveFrom);
      const leaveTo = getClassList(props.leaveTo);
      const entered = getClassList(props.entered);
      if (props.beforeLeave) {
        props.beforeLeave();
      }
      if (transitionParent) {
        transitionParent.register();
      }
      removeClassList(element, entered);
      setState("leave-from");
      addClassList(element, leave);
      addClassList(element, leaveFrom);
      requestAnimationFrame(() => {
        removeClassList(element, leaveFrom);
        setState("leave-to");
        addClassList(element, leaveTo);
      });
      const endTransition = () => {
        removeClassList(element, leave);
        removeClassList(element, leaveTo);
        setVisible(false);
        if (transitionParent) {
          transitionParent.unregister();
        }
        if (props.afterLeave) {
          props.afterLeave();
        }
      };
      element.addEventListener("transitionend", endTransition, { once: true });
      element.addEventListener("animationend", endTransition, { once: true });
    }
  }
  createEffect47(() => {
    const shouldShow = values.show;
    if (shouldShow) {
      setVisible(true);
    }
    const internalRef = ref();
    if (internalRef instanceof HTMLElement) {
      if (shouldShow) {
        transition(internalRef, true);
      } else if (transitionChildren.done()) {
        transition(internalRef, false);
      }
    } else {
      initial = true;
    }
  });
  return createComponent71(TransitionCounterContext.Provider, {
    value: transitionChildren,
    get children() {
      return createUnmountable(
        props,
        visible,
        () => createDynamic(
          () => props.as || "div",
          mergeProps75(
            omitProps74(props, [
              "as",
              "enter",
              "enterFrom",
              "enterTo",
              "leave",
              "leaveFrom",
              "leaveTo",
              "unmount",
              "afterEnter",
              "afterLeave",
              "appear",
              "beforeEnter",
              "beforeLeave",
              "entered",
              "ref"
            ]),
            {
              ref: setRef,
              get "tc-transition"() {
                return state();
              }
            }
          )
        )
      );
    }
  });
}
function Transition(props) {
  return createComponent71(TransitionRootContext.Provider, {
    value: props,
    get children() {
      return createComponent71(
        TransitionChild,
        omitProps74(props, ["show"])
      );
    }
  });
}

// src/states/create-input-state.ts
import {
  createComponent as createComponent72,
  createContext as createContext33,
  createMemo as createMemo17,
  createSignal as createSignal13,
  useContext as useContext33
} from "solid-js";
function createInputState(options) {
  let signal;
  let setSignal;
  if ("defaultValue" in options) {
    const [input, setInput] = createSignal13(
      options.defaultValue
    );
    signal = input;
    setSignal = (value) => {
      setInput(value);
      if (options.onChange) {
        options.onChange(value);
      }
    };
  } else {
    signal = () => options.value;
    setSignal = (value) => {
      if (options.onChange) {
        options.onChange(value);
      }
    };
  }
  return {
    value() {
      return signal();
    },
    setState(value) {
      if (!options.disabled) {
        setSignal(value);
      }
    },
    disabled() {
      return !!options.disabled;
    }
  };
}
var InputStateContext = createContext33();
function useInputState() {
  const ctx = useContext33(InputStateContext);
  assert(ctx, new Error("Missing <InputStateProvider>"));
  return ctx;
}
function InputStateChild(props) {
  const state = useInputState();
  return createMemo17(() => {
    const current = props.children;
    if (typeof current === "function" && current.length === 1) {
      return createMemo17(() => current(state));
    }
    return current;
  });
}

// src/utils/Fragment.ts
import { createMemo as createMemo18 } from "solid-js";
function Fragment(props) {
  return createMemo18(() => props.children);
}
export {
  Accordion,
  AccordionButton,
  AccordionHeader,
  AccordionItem,
  AccordionPanel,
  Alert,
  AlertDialog,
  AlertDialogDescription,
  AlertDialogOverlay,
  AlertDialogPanel,
  AlertDialogTitle,
  AutocompleteStateChild,
  Button,
  CheckStateChild,
  Checkbox,
  CheckboxDescription,
  CheckboxIndicator,
  CheckboxLabel,
  ColorSchemeProvider,
  Combobox,
  ComboboxInput,
  ComboboxLabel,
  ComboboxOption,
  ComboboxOptions,
  Command,
  CommandBar,
  CommandBarDescription,
  CommandBarOverlay,
  CommandBarPanel,
  CommandBarTitle,
  CommandInput,
  CommandLabel,
  CommandOption,
  CommandOptions,
  ContextMenu,
  ContextMenuBoundary,
  ContextMenuOverlay,
  ContextMenuPanel,
  Dialog,
  DialogDescription,
  DialogOverlay,
  DialogPanel,
  DialogTitle,
  Disclosure,
  DisclosureButton,
  DisclosurePanel,
  DisclosureStateChild,
  Feed,
  FeedArticle,
  FeedArticleDescription,
  FeedArticleLabel,
  FeedContent,
  FeedLabel,
  Fragment,
  InputStateChild,
  Listbox,
  ListboxButton,
  ListboxLabel,
  ListboxOption,
  ListboxOptions,
  Menu,
  MenuChild,
  MenuItem,
  Popover,
  PopoverButton,
  PopoverOverlay,
  PopoverPanel,
  RadioGroup,
  RadioGroupDescription,
  RadioGroupLabel,
  RadioGroupOption,
  Select,
  SelectOption,
  SelectOptionStateChild,
  SelectStateChild,
  Tab,
  TabGroup,
  TabList,
  TabPanel,
  Toast,
  Toaster,
  ToasterStore,
  Toggle,
  ToggleStateChild,
  Toolbar,
  Transition,
  TransitionChild,
  createCheckState,
  createDisclosureState,
  createInputState,
  createMultipleAutocompleteState,
  createMultipleSelectState,
  createSelectOptionState,
  createSingleAutocompleteState,
  createSingleSelectState,
  createToggleState,
  useAutocompleteState,
  useCheckState,
  useColorScheme,
  useDisclosureState,
  useInputState,
  useNativeColorScheme,
  usePreferredColorScheme,
  useSelectOptionState,
  useSelectState,
  useToaster,
  useToggleState
};
//# sourceMappingURL=index.mjs.map
