import { createRouter } from "radix3";
import fileRoutes from "vinxi/routes";
export const pageRoutes = defineRoutes(fileRoutes.filter(o => o.page));
function defineRoutes(fileRoutes) {
    function processRoute(routes, route, id, full) {
        const parentRoute = Object.values(routes).find(o => {
            return id.startsWith(o.id + "/");
        });
        if (!parentRoute) {
            routes.push({ ...route, id, path: id.replace(/\/\([^)/]+\)/g, "").replace(/\([^)/]+\)/g, "") });
            return routes;
        }
        processRoute(parentRoute.children || (parentRoute.children = []), route, id.slice(parentRoute.id.length), full);
        return routes;
    }
    return fileRoutes
        .sort((a, b) => a.path.length - b.path.length)
        .reduce((prevRoutes, route) => {
        return processRoute(prevRoutes, route, route.path, route.path);
    }, []);
}
export function matchAPIRoute(path, method) {
    const match = router.lookup(path);
    if (match && match.route) {
        const handler = match.route[`$${method}`];
        if (handler === undefined)
            return;
        return {
            handler,
            params: match.params
        };
    }
}
function containsHTTP(route) {
    return route["$GET"] || route["$POST"] || route["$PUT"] || route["$PATCH"] || route["$DELETE"];
}
const router = createRouter({
    routes: fileRoutes.reduce((memo, route) => {
        if (!containsHTTP(route))
            return memo;
        let path = route.path.replace(/\/\([^)/]+\)/g, "").replace(/\([^)/]+\)/g, "").replace(/\*([^/]*)/g, (_, m) => `**:${m}`);
        if (/:[^/]*\?/g.test(path)) {
            throw new Error(`Optional parameters are not supported in API routes: ${path}`);
        }
        if (memo[path]) {
            throw new Error(`Duplicate API routes for "${path}" found at "${memo[path].route.path}" and "${route.path}"`);
        }
        memo[path] = { route };
        return memo;
    }, {})
});
